{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Academy: Federated Actors and Agents","text":"<p>Academy is a modular and extensible middleware for building and deploying stateful actors and autonomous agents across distributed systems and federated research infrastructure. In Academy, you can:</p> <ul> <li>\u2699\ufe0f  Express agent behavior and state in code</li> <li>\ud83d\udceb Manage inter-agent coordination and asynchronous communication</li> <li>\ud83c\udf10 Deploy agents across distributed, federated, and heterogeneous resources</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Academy is available on PyPI.</p> <pre><code>pip install academy-py\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Agents in Academy are defined by a <code>Behavior</code>, a class with methods decorated with <code>@action</code> can be invoked by peers and method decorated with <code>@loop</code> run autonomous control loops.</p> <p>The below sensor monitoring behavior periodically reads a sensor in the <code>monitor()</code> loop and processes the reading if a threshold is met. Clients or peers can invoke the <code>get_last_reading()</code> and <code>set_process_threshold()</code> actions remotely to interact with the monitor agent.</p> <pre><code>import time, threading\nfrom academy.behavior import Behavior, action, loop\n\nclass SensorMonitorAgent(Behavior):\n    def __init__(self) -&gt; None:\n        self.last_reading: float | None = None\n        self.process_threshold: float = 1.0\n\n    @action\n    def get_last_reading(self) -&gt; float | None:\n        return self.last_reading\n\n    @action\n    def set_process_threshold(self, value: float) -&gt; None:\n        self.process_threshold = value\n\n    @loop\n    def monitor(self, shutdown: threading.Event) -&gt; None:\n        while not shutdown.is_set():\n            value = read_sensor_data()\n            self.last_reading = value:\n            if value &gt;= self.process_threshold:\n                process_reading(value)\n            time.sleep(1)\n</code></pre> <p>Entities communicate asynchronously through handles, sending messages to and receiving messages from a mailbox managed by an <code>Exchange</code>. The <code>Launcher</code> abstracts the remote execution of an agent, and the <code>Manager</code> provides easy management of handles, launchers, and the exchange.</p> <pre><code>from academy.exchange.thread import ThreadExchange\nfrom academy.launcher.thread import ThreadLauncher\nfrom academy.manager import Manager\n\nwith Manager(\n    exchange=ThreadExchange(),  # Replace with other implementations\n    launcher=ThreadLauncher(),  # for distributed deployments\n) as manager:\n    behavior = SensorMonitorAgent()  # From the above block\n    agent_handle = manager.launch(behavior)\n\n    agent_handle.set_process_threshold(2.0).result()\n    time.sleep(5)\n    value = agent_handle.get_last_reading().result()\n\n    manager.shutdown(handle, blocking=True)\n</code></pre> <p>Learn more about Academy in Getting Started.</p>"},{"location":"#what-can-be-an-agent","title":"What can be an agent?","text":"<p>In Academy, an agent is a primitive entity that (1) has internal state, (2) performs actions, and (3) communicates with other agents.</p> <p>This allows for range of agent implementations\u2014Academy agents are building blocks for constructing more complex agent-based systems.</p> <p>For example, Academy can be use to create the following:</p> <ul> <li>Stateful Actors: Actors manage their own data and respond to requests in a distributed system.</li> <li>LLM Agents: Integrate LLM-based reasoning and tool calling.</li> <li>Embodied Agents: The \"brain\" controlling a robot or simulated entity where action are translated into motor commands or environment manipulations.</li> <li>Computational Units: Encapsulate a specific computational task, like running a simulation, processing data, or training a machine learning model.</li> <li>Orchestrators: Manage or coordinate the activities of other agents, distributing tasks and monitoring progress.</li> <li>Data Interfaces: Interact with external data sources, such as databases, file systems, or sensors, providing a consistent interface for data access and manipulation.</li> </ul>"},{"location":"#why-academy","title":"Why Academy?","text":"<p>Academy offers a powerful and flexible framework for building sophisticated, distributed agent-based systems, particularly well-suited for the complexities of scientific applications. Here's what makes Academy valuable:</p> <ul> <li>Stateful Agents: Academy enables agents to maintain state, which is crucial for managing long-running processes, tracking context across steps, and implementing agents that need to \"remember\" information.</li> <li>Agent Autonomy: Academy allows agents to have autonomous control loops, empowering them to make decisions, react to events, and execute tasks independently.</li> <li>Flexible Deployment: Academy provides tools for managing agent deployment, communication, and coordination in complex environments such that applications can leverage heterogeneous, distributed, and federated resources.</li> <li>Foundation for Sophisticated Applications: Academy primitives offer a strong foundation for building highly specialized and sophisticated agent-based systems that go beyond standard LLM use cases, allowing for fine-grained control and optimization tailored to specific scientific applications.</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>The Academy preprint is available on arXiv.</p> <pre><code>@misc{pauloski2025academy,\n    title = {{E}mpowering {S}cientific {W}orkflows with {F}ederated {A}gents},\n    author = {J. Gregory Pauloski and Yadu Babuji and Ryan Chard and Mansi Sakarvadia and Kyle Chard and Ian Foster},\n    archivePrefix = {arXiv},\n    eprint = {2505.05428},\n    primaryClass = {cs.MA},\n    url = {https://arxiv.org/abs/2505.05428},\n    year = {2025},\n}\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#architecture","title":"Architecture","text":"<p>Agents and clients in Academy interact via handles to invoke actions asynchronously. Agents implement a behavior, defined by their actions, control loops, and state. Academy decouples the control and data planes through the launcher and exchange components that manage spawning agents and communication, respectively.</p> <p>An Academy application includes one or more agents and zero or more clients. An agent is a process that executes a behavior, where a behavior is defined by a local state, a set of actions, and a set of control loops. Agents are executed remotely using a launcher. Once running, an agent concurrently executes all of its control loops and listens for messages from clients, which can be other agents or programs.</p> <p>A client interacts with an agent through a handle}, which acts like a reference to the remote agent and translates method calls into action request messages. Each entity (i.e., client or agent) has an associated mailbox that maintains a queue of messages sent to that entity by other entities. Mailboxes are maintained by an exchange such that any client with access to a given exchange can send messages to the mailbox of another agent in the exchange and receive a response through its own mailbox.</p>"},{"location":"concepts/#agents","title":"Agents","text":"<p>In Academy, the concept of an \"agent\" is intentionally simple. The agent primitive is, at its core, is an entity that:</p> <ul> <li>Has state: Maintains information about its current situation, past history, or internal variables.</li> <li>Performs actions: Execute specific operations or tasks.</li> <li>Communicates: Exchanges messages or data with other clients, agents, or the environment.</li> </ul> <p>In essence, Academy agents can be thought of as building blocks for more complex or specialized agent-based systems.</p>"},{"location":"concepts/#behaviors","title":"Behaviors","text":"<p>An academy.behavior is implemented as a Python class that inherits from the base <code>Behavior</code> type. This class-based approach is extensible through inheritance and polymorphism.</p> <ul> <li>State is stored as instance attributes on the agent's behavior type. Instance attributes maintain the agent's state, and methods define the actions and control loops.</li> <li>Actions can be performed in two ways: <code>@action</code> decorated methods allow other entities to invoke the method remotely and <code>@loop</code> decorated methods run non-terminating control loops that enable an agent to autonomously perform actions.</li> <li>Communication between entities in managed via <code>Handles</code> which are client interfaces to remote agents used to invoke actions, ping, and shutdown.</li> </ul>"},{"location":"concepts/#execution","title":"Execution","text":"<p>The <code>Agent</code> is a multithreaded entity that executes a provided behavior and manages communication with other entities. <code>Agent.run()</code> executed the agent by (1) invokes the <code>on_setup()</code> callback of the behavior, (2) starts each <code>@loop</code> method in a separate thread, (3) spawns a thread to listen for new messages in the agent's mailbox, and (4) waits for the agent to be shut down. Each <code>@action</code> method is executed in a thread pool when requested remotely so as to not block the handling of other messages.</p> <p>Note</p> <p>The use of multi-threading means that behavior implementations must be aware of the caveats of Python's global interpreter lock (GIL). Compute-heavy actions can dispatch work to other parallel executors, such as a <code>ProcessPoolExecutor</code>, Dask Distributed, Parsl, or Ray.</p> <p>Agents are designed to be long-running, but can be terminated by sending a shutdown request. Upon shutdown, the shutdown <code>threading.Event</code>, passed to each <code>@loop</code>, is set; running threads are instructed to shutdown and waited on; and the <code>on_shutdown()</code> callback is invoked. Agents can terminate themselves by setting the shutdown event; exceptions raised in <code>@loop</code> methods will shutdown the agent by default, and exceptions raised when executing <code>@action</code> methods are caught and returned to the remote caller.</p>"},{"location":"concepts/#handles","title":"Handles","text":"<p>Interacting with an agent is asynchronous; an entity sends a message to the agent's mailbox and waits to receive a response message in its own mailbox. A <code>Handle</code> is a client interface to a remote agent used to invoke actions, ping, and shutdown the agent. Handles translate method calls into a request messages sent via the exchange and returning a <code>Futures</code>. The handle also listens for response messages and accordingly sets the result on the appropriate <code>Futures</code>.</p>"},{"location":"concepts/#exchanges-and-mailboxes","title":"Exchanges and Mailboxes","text":"<p>Entities communicate by sending and receiving messages to and from mailboxes. Mailboxes are managed by an <code>Exchange</code>, and this protocol defines methods for registering new agent or client mailboxes, sending and receiving messages, and creating handles to remote agents. Registering an agent or client involves creating a unique ID for the entity, which is also the address of its mailbox, and initializing that mailbox within the exchange.</p> <p>A mailbox has two states: open and closed. Open indicates that the entity is accepting messages, even if, for example, an agent has not yet started or is temporarily offline. Closed indicates permanent termination of the entity and will cause <code>MailboxClosedError</code> to be raised by subsequent send or receive operations to that mailbox.</p> <p>Academy provides many exchange implementations for different scenarios, such as:</p> <ul> <li><code>ThreadExchange</code>: Uses thread-safe queues for single-process, multiple-agent scenarios. Useful for testing and development.</li> <li><code>HttpExchange</code>: Centralized service that maintains mailboxes and exposes a REST API. Lower performance but easy to extend with common authentication tools.</li> <li><code>RedisExchange</code>: Stores state and mailboxes in a Redis server. Use of Redis enables optional replication and cloud-hosting for improved resilience and availability.</li> <li><code>HybridExchange</code>: Entities host their mailbox locally and message each other directly over TCP when possible. Redis is used to map mailbox IDs to address and port pairs, and to store messages for offline entities or when two entities cannot directly communicate (such as when behind NATs).</li> </ul>"},{"location":"concepts/#launchers","title":"Launchers","text":"<p>An agent can be run manually, but the intended method of execution is via a launcher, which manages the initialization and execution of agents on remote resources. The <code>Launcher</code> protocol defines a <code>launch()</code> method with parameters for the behavior, exchange, and agent ID and returns a handle to the launched agent.</p> <p>Available launchers include:</p> <ul> <li><code>ThreadLauncher</code>: Runs agents in separate threads of the same process. Useful for local development and testing or for light-weight or I/O bound agents.</li> <li><code>ExecutorLauncher</code>: Runs agents in any <code>concurrent.futures.Executor</code> compatible executor, such as a <code>ProcessPoolExecutor</code>, Parsl, or Globus Compute.</li> </ul>"},{"location":"concepts/#managers","title":"Managers","text":"<p>A <code>Manager</code> combines an exchange and one or more launchers to provide a single interface for launching, using, and managing agents. Each manager has a single mailbox in the exchange and multiplexes that mailbox across handles to all of the agents that it manages. This reduces boilerplate code, improves communication efficiency, and ensures stateful resources and threads are appropriately cleaned up.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Open a new issue if you have a question not answered in the FAQ, Guides, or API docs.</p> <p>Warning</p> <p>FAQs are under development!</p>"},{"location":"get-started/","title":"Getting Started","text":""},{"location":"get-started/#installation","title":"Installation","text":"<p>You can install Academy with <code>pip</code> or from source. We suggest installing within a virtual environment (e.g., <code>venv</code> or Conda). <pre><code>python -m venv venv\n. venv/bin/activate\n</code></pre></p> <p>Option 1: Install from PyPI: <pre><code>pip install academy-py\n</code></pre></p> <p>Option 2: Install from source: <pre><code>git clone git@github.com:proxystore/academy\ncd academy\npip install -e .  # -e for editable mode\n</code></pre></p>"},{"location":"get-started/#a-basic-example","title":"A Basic Example","text":"<p>The following script defines, initializes, and launches a simple agent that performs a single action. Click on the plus (<code>+</code>) signs to learn more.</p> example.py<pre><code>from academy.behavior import Behavior, action\nfrom academy.exchange.thread import ThreadExchange\nfrom academy.launcher.thread import ThreadLauncher\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\nclass ExampleAgent(Behavior):  # (1)!\n    @action  # (2)!\n    def square(self, value: float) -&gt; float:\n        return value * value\n\ndef main() -&gt; None:\n    init_logging('INFO')\n\n    with Manager(  # (3)!\n        exchange=ThreadExchange(),  # (4)!\n        launcher=ThreadLauncher(),  # (5)!\n    ) as manager:\n        agent_handle = manager.launch(ExampleAgent())  # (6)!\n\n        future = agent_handle.square(2)  # (7)!\n        assert future.result() == 4\n\n        agent_handle.shutdown()  # (8)!\n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li>Running agents implement a <code>Behavior</code>.</li> <li>Behavior methods decorated with <code>@action</code> can be invoked remotely by clients and other agents. An agent can call action methods on itself as normal methods.</li> <li>The <code>Manager</code> is a high-level interface that reduces boilerplate code when launching and managing agents. It will also manage clean up of resources and shutting down agents when the context manager exits.</li> <li>The <code>ThreadExchange</code> manages message passing between clients and agents running in different threads of a single process.</li> <li>The <code>ThreadLauncher</code> launches agents in threads of the current process.</li> <li>An instantiated behavior (here, <code>ExampleAgent</code>) can be launched with <code>Manager.launch()</code>, returning a handle to the remote agent.</li> <li>Interact with running agents via a <code>RemoteHandle</code>. Invoking an action returns a future to the result.</li> <li>Agents can be shutdown via a handle or the manager.</li> </ol> <p>Running this script with logging enabled produces the following output: <pre><code>$ python example.py\nINFO (root) Configured logger (stdout-level=INFO, logfile=None, logfile-level=None)\nINFO (academy.manager) Initialized manager (ClientID&lt;6e890226&gt;; ThreadExchange&lt;4401447664&gt;)\nINFO (academy.manager) Launched agent (AgentID&lt;ad6faf7e&gt;; Behavior&lt;ExampleAgent&gt;)\nINFO (academy.agent) Running agent (AgentID&lt;ad6faf7e&gt;; Behavior&lt;ExampleAgent&gt;)\nINFO (academy.agent) Shutdown agent (AgentID&lt;ad6faf7e&gt;; Behavior&lt;ExampleAgent&gt;)\nINFO (academy.manager) Closed manager (ClientID&lt;6e890226&gt;)\n</code></pre></p>"},{"location":"get-started/#control-loops","title":"Control Loops","text":"<p>Control loops define the autonomous behavior of a running agent and are created by decorating a method with <code>@loop</code>.</p> <pre><code>import threading\nimport time\nfrom academy.behavior import loop\n\nclass ExampleAgent(Behavior):\n    @loop\n    def counter(self, shutdown: threading.Event) -&gt; None:\n        count = 0\n        while not shutdown.is_set():\n            print(f'Count: {count}')\n            count += 1\n            time.sleep(1)\n</code></pre> <p>All control loops are started in separate threads when an agent is executed, and run until the control loop exits or the agent is shut down, as indicated by the <code>shutdown</code> event.</p>"},{"location":"get-started/#agent-to-agent-interaction","title":"Agent to Agent Interaction","text":"<p>Agent handles can be passed to other agents to facilitate agent-to-agent interaction. Here, a <code>Coordinator</code> is initialized with handles to two other agents implementing the <code>Lowerer</code> and <code>Reverser</code> behaviors, respectively.</p> <pre><code>from academy.behavior import action\nfrom academy.behavior import Behavior\nfrom academy.handle import Handle\n\nclass Coordinator(Behavior):\n    def __init__(\n        self,\n        lowerer: Handle[Lowerer],\n        reverser: Handle[Reverser],\n    ) -&gt; None:\n        self.lowerer = lowerer\n        self.reverser = reverser\n\n    @action\n    def process(self, text: str) -&gt; str:\n        text = self.lowerer.action('lower', text).result()\n        text = self.reverser.action('reverse', text).result()\n        return text\n\nclass Lowerer(Behavior):\n    @action\n    def lower(self, text: str) -&gt; str:\n        return text.lower()\n\nclass Reverser(Behavior):\n    @action\n    def reverse(self, text: str) -&gt; str:\n        return text[::-1]\n</code></pre> <p>After launching the <code>Lowerer</code> and <code>Reverser</code>, the respective handles can be used to initialize the <code>Coordinator</code> before launching it.</p> <pre><code>from academy.exchange.thread import ThreadExchange\nfrom academy.launcher.thread import ThreadLauncher\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\ndef main() -&gt; None:\n    init_logging('INFO')\n\n    with Manager(\n        exchange=ThreadExchange(),\n        launcher=ThreadLauncher(),\n    ) as manager:\n        lowerer = manager.launch(Lowerer())\n        reverser = manager.launch(Reverser())\n        coordinator = manager.launch(Coordinator(lowerer, reverser))\n\n        text = 'DEADBEEF'\n        expected = 'feebdaed'\n\n        future = coordinator.process(text)\n        assert future.result() == expected\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"get-started/#distributed-execution","title":"Distributed Execution","text":"<p>The prior examples have launched agent in threads of the main process, but in practice agents are launched in different processes, possibly on the same node or remote nodes. The prior example can be executed in a distributed fashion by changing the launcher and exchange to implementations which support distributed execution. Below, a Redis server server (via the <code>RedisExchange</code>) is used to support messaging between distributed agents executed with a <code>ProcessPoolExecutor</code> (via the <code>ExecutorLauncher</code>).</p> <pre><code>from concurrent.futures import ProcessPoolExecutor\nfrom academy.exchange.redis import RedisExchange\nfrom academy.launcher.executor import ExecutorLauncher\n\ndef main() -&gt; None:\n    process_pool = ProcessPoolExecutor(max_processes=4)\n    with Manager(\n        exchange=RedisExchange('&lt;REDIS HOST&gt;', port=6379),\n        launcher=ExecutorLauncher(process_pool),\n    ) as manager:\n        ...\n</code></pre> <p>The <code>ExecutorLauncher</code> is compatible with any <code>concurrent.futures.Executor</code>.</p>"},{"location":"api/","title":"academy","text":"<code>academy/__init__.py</code>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>academy</li> <li>academy.agent</li> <li>academy.behavior</li> <li>academy.event</li> <li>academy.exception</li> <li>academy.exchange<ul> <li>http</li> <li>hybrid</li> <li>proxystore</li> <li>queue</li> <li>redis</li> <li>thread</li> </ul> </li> <li>academy.handle</li> <li>academy.identifier</li> <li>academy.launcher<ul> <li>executor</li> <li>thread</li> </ul> </li> <li>academy.logging</li> <li>academy.manager</li> <li>academy.message</li> <li>academy.multiplex</li> <li>academy.serialize</li> <li>academy.socket</li> <li>academy.state</li> </ul>"},{"location":"api/agent/","title":"academy.agent","text":"<code>academy/agent.py</code>"},{"location":"api/agent/#academy.agent.AgentRunConfig","title":"AgentRunConfig  <code>dataclass</code>","text":"<pre><code>AgentRunConfig(\n    close_exchange_on_exit: bool = True,\n    max_action_concurrency: int | None = None,\n    terminate_on_error: bool = True,\n    terminate_on_exit: bool = True,\n)\n</code></pre> <p>Agent run configuration.</p> <p>Attributes:</p> <ul> <li> <code>close_exchange_on_exit</code>               (<code>bool</code>)           \u2013            <p>Close the exchange interface when the agent exits. Typically this should be <code>True</code> to clean up resources, except when multiple agents are running in the same process and sharing an exchange.</p> </li> <li> <code>max_action_concurrency</code>               (<code>int | None</code>)           \u2013            <p>Maximum size of the thread pool used to concurrently execute action requests.</p> </li> <li> <code>terminate_on_error</code>               (<code>bool</code>)           \u2013            <p>Terminate the agent by closing its mailbox permanently if the agent fails.</p> </li> <li> <code>terminate_on_exit</code>               (<code>bool</code>)           \u2013            <p>Terminate the agent by closing its mailbox permanently after the agent exits.</p> </li> </ul>"},{"location":"api/agent/#academy.agent.Agent","title":"Agent","text":"<pre><code>Agent(\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT],\n    exchange: Exchange,\n    config: AgentRunConfig | None = None\n)\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code></p> <p>Executable agent.</p> <p>An agent executes predefined <code>Behavior</code>. An agent can operate independently or as part of a broader multi-agent system.</p> Note <p>An agent can only be run once. After <code>shutdown()</code> is called, later operations will raise a <code>RuntimeError</code>.</p> Note <p>If any <code>@loop</code> method raises an error, the agent will be signaled to shutdown.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior that the agent will exhibit.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of this agent in a multi-agent system.</p> </li> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Message exchange of multi-agent system. The agent will close the exchange when it finished running.</p> </li> <li> <code>config</code>               (<code>AgentRunConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent execution parameters.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def __init__(\n    self,\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT],\n    exchange: Exchange,\n    config: AgentRunConfig | None = None,\n) -&gt; None:\n    self.agent_id = agent_id\n    self.behavior = behavior\n    self.exchange = exchange\n    self.config = config if config is not None else AgentRunConfig()\n\n    self._actions = behavior.behavior_actions()\n    self._loops = behavior.behavior_loops()\n\n    self._shutdown = threading.Event()\n    self._expected_shutdown = True\n    self._state_lock = threading.Lock()\n    self._state = _AgentState.INITIALIZED\n\n    self._action_pool: ThreadPoolExecutor | None = None\n    self._action_futures: dict[ActionRequest, Future[None]] = {}\n    self._loop_pool: ThreadPoolExecutor | None = None\n    self._loop_futures: dict[Future[None], str] = {}\n\n    self._multiplexer = MailboxMultiplexer(\n        self.agent_id,\n        self.exchange,\n        request_handler=self._request_handler,\n    )\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; None\n</code></pre> <p>Alias for run().</p> Source code in <code>academy/agent.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"Alias for [run()][academy.agent.Agent.run].\"\"\"\n    self.run()\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.action","title":"action","text":"<pre><code>action(action: str, args: Any, kwargs: Any) -&gt; Any\n</code></pre> <p>Invoke an action of the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Name of action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>)           \u2013            <p>Tuple of positional arguments.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>)           \u2013            <p>Dictionary of keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>if an action with this name is not implemented by the behavior of the agent.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def action(self, action: str, args: Any, kwargs: Any) -&gt; Any:\n    \"\"\"Invoke an action of the agent.\n\n    Args:\n        action: Name of action to invoke.\n        args: Tuple of positional arguments.\n        kwargs: Dictionary of keyword arguments.\n\n    Returns:\n        Result of the action.\n\n    Raises:\n        AttributeError: if an action with this name is not implemented by\n            the behavior of the agent.\n    \"\"\"\n    logger.debug('Invoking \"%s\" action on %s', action, self.agent_id)\n    if action not in self._actions:\n        raise AttributeError(\n            f'Agent[{type(self.behavior).__name__}] does not have an '\n            f'action named \"{action}\".',\n        )\n    return self._actions[action](*args, **kwargs)\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the agent.</p> <p>Starts the agent, waits for another thread to call <code>signal_shutdown()</code>, and then shuts down the agent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>Any exceptions raised inside threads.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the agent.\n\n    Starts the agent, waits for another thread to call `signal_shutdown()`,\n    and then shuts down the agent.\n\n    Raises:\n        Exception: Any exceptions raised inside threads.\n    \"\"\"\n    try:\n        self.start()\n        self._shutdown.wait()\n    finally:\n        self.shutdown()\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the agent.</p> Note <p>This method is idempotent; it will return if the agent is already running. However, it will raise an error if the agent is shutdown.</p> <ol> <li>Binds all unbound handles to remote agents to this agent.</li> <li>Calls <code>Behavior.on_setup()</code>.</li> <li>Starts threads for all control loops defined on the agent's    <code>Behavior</code>.</li> <li>Starts a thread for listening to messages from the    <code>Exchange</code> (if provided).</li> </ol> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the agent has been shutdown.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the agent.\n\n    Note:\n        This method is idempotent; it will return if the agent is\n        already running. However, it will raise an error if the agent\n        is shutdown.\n\n    1. Binds all unbound handles to remote agents to this agent.\n    1. Calls [`Behavior.on_setup()`][academy.behavior.Behavior.on_setup].\n    1. Starts threads for all control loops defined on the agent's\n       [`Behavior`][academy.behavior.Behavior].\n    1. Starts a thread for listening to messages from the\n       [`Exchange`][academy.exchange.Exchange] (if provided).\n\n    Raises:\n        RuntimeError: If the agent has been shutdown.\n    \"\"\"\n    with self._state_lock:\n        if self._state is _AgentState.SHUTDOWN:\n            raise RuntimeError('Agent has already been shutdown.')\n        elif self._state is _AgentState.RUNNING:\n            return\n\n        logger.debug(\n            'Starting agent... (%s; %s)',\n            self.agent_id,\n            self.behavior,\n        )\n        self._state = _AgentState.STARTING\n        self._bind_handles()\n        self.behavior.on_setup()\n        self._action_pool = ThreadPoolExecutor(\n            self.config.max_action_concurrency,\n        )\n        self._loop_pool = ThreadPoolExecutor(\n            max_workers=len(self._loops) + 1,\n        )\n\n        for name, method in self._loops.items():\n            loop_future = self._loop_pool.submit(method, self._shutdown)\n            self._loop_futures[loop_future] = name\n            loop_future.add_done_callback(self._loop_callback)\n\n        listener_future = self._loop_pool.submit(self._multiplexer.listen)\n        self._loop_futures[listener_future] = '_multiplexer.listen'\n\n        self._state = _AgentState.RUNNING\n\n        logger.info('Running agent (%s; %s)', self.agent_id, self.behavior)\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shutdown the agent.</p> Note <p>This method is idempotent.</p> <ol> <li>Sets the shutdown <code>Event</code> passed to all control    loops.</li> <li>Waits for any currently executing actions to complete.</li> <li>Closes the agent's mailbox indicating that no further messages    will be processed.</li> <li>Waits for the control loop and message listener threads to exit.</li> <li>Optionally closes the exchange.</li> <li>Calls    <code>Behavior.on_shutdown()</code>.</li> </ol> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>Any exceptions raised inside threads.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown the agent.\n\n    Note:\n        This method is idempotent.\n\n    1. Sets the shutdown [`Event`][threading.Event] passed to all control\n       loops.\n    1. Waits for any currently executing actions to complete.\n    1. Closes the agent's mailbox indicating that no further messages\n       will be processed.\n    1. Waits for the control loop and message listener threads to exit.\n    1. Optionally closes the exchange.\n    1. Calls\n       [`Behavior.on_shutdown()`][academy.behavior.Behavior.on_shutdown].\n\n    Raises:\n        Exception: Any exceptions raised inside threads.\n    \"\"\"\n    with self._state_lock:\n        if self._state is _AgentState.SHUTDOWN:\n            return\n\n        logger.debug(\n            'Shutting down agent... (expected: %s; %s; %s)',\n            self._expected_shutdown,\n            self.agent_id,\n            self.behavior,\n        )\n        self._state = _AgentState.TERMINTATING\n        self._shutdown.set()\n\n        # Cause the multiplexer message listener thread to exit by closing\n        # the mailbox the multiplexer is listening to. This is done\n        # first so we stop receiving new requests.\n        self._multiplexer.terminate()\n        for future, name in self._loop_futures.items():\n            if name == '_multiplexer.listen':\n                future.result()\n\n        # Wait for currently running actions to complete. No more\n        # should come in now that multiplexer's listener thread is done.\n        if self._action_pool is not None:\n            self._action_pool.shutdown(wait=True, cancel_futures=True)\n\n        # Shutdown the loop pool after waiting on the loops to exit.\n        if self._loop_pool is not None:\n            self._loop_pool.shutdown(wait=True)\n\n        if (\n            self._expected_shutdown and not self.config.terminate_on_exit\n        ) or (\n            not self._expected_shutdown\n            and not self.config.terminate_on_error\n        ):\n            # TODO: This is a hack because we need to close the mailbox\n            # for the multiplexer listener thread to exit, but in some\n            # cases we don't actually want to close it permanently. This\n            # means there is a race where the mailbox is temporarily\n            # closed.\n            self.exchange.register_agent(\n                type(self.behavior),\n                agent_id=self.agent_id,\n            )\n\n        self.behavior.on_shutdown()\n\n        # Close the exchange last since the actions that finished\n        # up may still need to use it to send replies.\n        if self.config.close_exchange_on_exit:\n            self.exchange.close()\n\n        self._state = _AgentState.SHUTDOWN\n\n        # Raise any exceptions from the loop threads as the final step.\n        _raise_future_exceptions(tuple(self._loop_futures))\n\n        logger.info(\n            'Shutdown agent (%s; %s)',\n            self.agent_id,\n            self.behavior,\n        )\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.signal_shutdown","title":"signal_shutdown","text":"<pre><code>signal_shutdown(expected: bool = True) -&gt; None\n</code></pre> <p>Signal that the agent should exit.</p> <p>If the agent has not started, this will cause the agent to immediately shutdown when next started. If the agent is shutdown, this has no effect.</p> Source code in <code>academy/agent.py</code> <pre><code>def signal_shutdown(self, expected: bool = True) -&gt; None:\n    \"\"\"Signal that the agent should exit.\n\n    If the agent has not started, this will cause the agent to immediately\n    shutdown when next started. If the agent is shutdown, this has no\n    effect.\n    \"\"\"\n    self._expected_shutdown = expected\n    self._shutdown.set()\n</code></pre>"},{"location":"api/behavior/","title":"academy.behavior","text":"<code>academy/behavior.py</code>"},{"location":"api/behavior/#academy.behavior.Behavior","title":"Behavior","text":"<p>Agent behavior base class.</p> <p>All <code>Agent</code> instances execute a behavior which is defined by a subclass of the <code>Behavior</code>. Each behavior is composed of three parts:   1. The <code>on_startup()</code> and      <code>on_shutdown()</code> methods      define callbacks that are invoked once at the start and end of an      agent's execution, respectively. The methods should be used to      initialize and cleanup stateful resources. Resource initialization      should not be performed in <code>__init__</code>.   2. Action methods annotated with <code>@action</code>      are methods that other agents can invoke on this agent. An agent      may also call it's own action methods as normal methods.   3. Control loop methods annotated with <code>@loop</code>      are executed in separate threads when the agent is executed.</p> Warning <p>This class cannot be instantiated directly and must be subclassed.</p>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_actions","title":"behavior_actions","text":"<pre><code>behavior_actions() -&gt; dict[str, Action[Any, Any]]\n</code></pre> <p>Get methods of this behavior type that are decorated as actions.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Action[Any, Any]]</code>           \u2013            <p>Dictionary mapping method names to action methods.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_actions(self) -&gt; dict[str, Action[Any, Any]]:\n    \"\"\"Get methods of this behavior type that are decorated as actions.\n\n    Returns:\n        Dictionary mapping method names to action methods.\n    \"\"\"\n    actions: dict[str, Action[Any, Any]] = {}\n    for name in dir(self):\n        attr = getattr(self, name)\n        if _is_agent_method_type(attr, 'action'):\n            actions[name] = attr\n    return actions\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_loops","title":"behavior_loops","text":"<pre><code>behavior_loops() -&gt; dict[str, ControlLoop]\n</code></pre> <p>Get methods of this behavior type that are decorated as loops.</p> <p>Returns:</p> <ul> <li> <code>dict[str, ControlLoop]</code>           \u2013            <p>Dictionary mapping method names to loop methods.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_loops(self) -&gt; dict[str, ControlLoop]:\n    \"\"\"Get methods of this behavior type that are decorated as loops.\n\n    Returns:\n        Dictionary mapping method names to loop methods.\n    \"\"\"\n    loops: dict[str, ControlLoop] = {}\n    for name in dir(self):\n        attr = getattr(self, name)\n        if _is_agent_method_type(attr, 'loop'):\n            loops[name] = attr\n    return loops\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_handles","title":"behavior_handles","text":"<pre><code>behavior_handles() -&gt; dict[\n    str,\n    Handle[Any] | HandleDict[Any, Any] | HandleList[Any],\n]\n</code></pre> <p>Get instance attributes that are agent handles.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Handle[Any] | HandleDict[Any, Any] | HandleList[Any]]</code>           \u2013            <p>Dictionary mapping attribute names to agent handles or             data structures of handles.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_handles(\n    self,\n) -&gt; dict[\n    str,\n    Handle[Any] | HandleDict[Any, Any] | HandleList[Any],\n]:\n    \"\"\"Get instance attributes that are agent handles.\n\n    Returns:\n        Dictionary mapping attribute names to agent handles or \\\n        data structures of handles.\n    \"\"\"\n    from academy.handle import Handle\n\n    # This import is deferred to prevent a cyclic import with\n    # academy.handle.\n    handles: dict[\n        str,\n        Handle[Any] | HandleDict[Any, Any] | HandleList[Any],\n    ] = {}\n    for name in dir(self):\n        attr = getattr(self, name)\n        if isinstance(attr, (Handle, HandleDict, HandleList)):\n            handles[name] = attr\n    return handles\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_handles_bind","title":"behavior_handles_bind","text":"<pre><code>behavior_handles_bind(\n    bind: Callable[[Handle[BehaviorT]], Handle[BehaviorT]],\n) -&gt; None\n</code></pre> <p>Bind all instance attributes that are agent handles.</p> <p>Parameters:</p> <ul> <li> <code>bind</code>               (<code>Callable[[Handle[BehaviorT]], Handle[BehaviorT]]</code>)           \u2013            <p>A callback that takes a handle and returns the same handle or a bound version of the handle.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_handles_bind(\n    self,\n    bind: Callable[[Handle[BehaviorT]], Handle[BehaviorT]],\n) -&gt; None:\n    \"\"\"Bind all instance attributes that are agent handles.\n\n    Args:\n        bind: A callback that takes a handle and returns the same handle\n            or a bound version of the handle.\n    \"\"\"\n    for attr, handles in self.behavior_handles().items():\n        if isinstance(handles, Handle):\n            setattr(self, attr, bind(handles))\n        elif isinstance(handles, HandleDict):\n            setattr(\n                self,\n                attr,\n                HandleDict({k: bind(h) for k, h in handles.items()}),\n            )\n        elif isinstance(handles, HandleList):\n            setattr(self, attr, HandleList(bind(h) for h in handles))\n        else:\n            raise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_mro","title":"behavior_mro  <code>classmethod</code>","text":"<pre><code>behavior_mro() -&gt; tuple[str, ...]\n</code></pre> <p>Get the method resolution order of the behavior.</p> Example <pre><code>&gt;&gt;&gt; from academy.behavior import Behavior\n&gt;&gt;&gt;\n&gt;&gt;&gt; class A(Behavior): ...\n&gt;&gt;&gt; class B(Behavior): ...\n&gt;&gt;&gt; class C(A): ...\n&gt;&gt;&gt; class D(A, B): ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; A.behavior_mro()\n('__main__.A',)\n&gt;&gt;&gt; B.behavior_mro()\n('__main__.B',)\n&gt;&gt;&gt; C.behavior_mro()\n('__main__.C', '__main__.A')\n&gt;&gt;&gt; D.behavior_mro()\n('__main__.D', '__main__.A', '__main__.B')\n</code></pre> <p>Returns:</p> <ul> <li> <code>tuple[str, ...]</code>           \u2013            <p>Tuple of fully-qualified paths of types in the MRO of this             behavior type, not including the base             <code>Behavior</code> or <code>object</code>.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>@classmethod\ndef behavior_mro(cls) -&gt; tuple[str, ...]:\n    \"\"\"Get the method resolution order of the behavior.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from academy.behavior import Behavior\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class A(Behavior): ...\n        &gt;&gt;&gt; class B(Behavior): ...\n        &gt;&gt;&gt; class C(A): ...\n        &gt;&gt;&gt; class D(A, B): ...\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; A.behavior_mro()\n        ('__main__.A',)\n        &gt;&gt;&gt; B.behavior_mro()\n        ('__main__.B',)\n        &gt;&gt;&gt; C.behavior_mro()\n        ('__main__.C', '__main__.A')\n        &gt;&gt;&gt; D.behavior_mro()\n        ('__main__.D', '__main__.A', '__main__.B')\n        ```\n\n    Returns:\n        Tuple of fully-qualified paths of types in the MRO of this \\\n        behavior type, not including the base \\\n        [`Behavior`][academy.behavior.Behavior] or [`object`][object].\n    \"\"\"\n    mro = cls.mro()\n    base_index = mro.index(Behavior)\n    mro = mro[:base_index]\n    return tuple(f'{t.__module__}.{t.__qualname__}' for t in mro)\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.on_setup","title":"on_setup","text":"<pre><code>on_setup() -&gt; None\n</code></pre> <p>Setup up resources needed for the agents execution.</p> <p>This is called before any control loop threads are started.</p> Source code in <code>academy/behavior.py</code> <pre><code>def on_setup(self) -&gt; None:\n    \"\"\"Setup up resources needed for the agents execution.\n\n    This is called before any control loop threads are started.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown() -&gt; None\n</code></pre> <p>Shutdown resources after the agents execution.</p> <p>This is called after control loop threads have exited.</p> Source code in <code>academy/behavior.py</code> <pre><code>def on_shutdown(self) -&gt; None:\n    \"\"\"Shutdown resources after the agents execution.\n\n    This is called after control loop threads have exited.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Action","title":"Action","text":"<p>               Bases: <code>Generic[P, R_co]</code>, <code>Protocol</code></p> <p>Action method protocol.</p>"},{"location":"api/behavior/#academy.behavior.Action.__call__","title":"__call__","text":"<pre><code>__call__(*arg: args, **kwargs: kwargs) -&gt; R_co\n</code></pre> <p>Expected signature of methods decorated as an action.</p> <p>In general, action methods can implement any signature.</p> Source code in <code>academy/behavior.py</code> <pre><code>def __call__(self, *arg: P.args, **kwargs: P.kwargs) -&gt; R_co:\n    \"\"\"Expected signature of methods decorated as an action.\n\n    In general, action methods can implement any signature.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/behavior/#academy.behavior.ControlLoop","title":"ControlLoop","text":"<p>               Bases: <code>Protocol</code></p> <p>Control loop method protocol.</p>"},{"location":"api/behavior/#academy.behavior.ControlLoop.__call__","title":"__call__","text":"<pre><code>__call__(shutdown: Event) -&gt; None\n</code></pre> <p>Expected signature of methods decorated as a control loop.</p> <p>Parameters:</p> <ul> <li> <code>shutdown</code>               (<code>Event</code>)           \u2013            <p>Event indicating that the agent has been instructed to shutdown and all control loops should exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Control loops should not return anything.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def __call__(self, shutdown: threading.Event) -&gt; None:\n    \"\"\"Expected signature of methods decorated as a control loop.\n\n    Args:\n        shutdown: Event indicating that the agent has been instructed to\n            shutdown and all control loops should exit.\n\n    Returns:\n        Control loops should not return anything.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/behavior/#academy.behavior.action","title":"action","text":"<pre><code>action(method: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> <p>Decorator that annotates a method of a behavior as an action.</p> <p>Marking a method of a behavior as an action makes the method available to other agents. I.e., peers within a multi-agent system can only invoke methods marked as actions on each other. This enables behaviors to define \"private\" methods.</p> Example <pre><code>from academy.behavior import Behavior, action\n\nclass Example(Behavior):\n    @action\n    def perform(self):\n        ...\n</code></pre> Source code in <code>academy/behavior.py</code> <pre><code>def action(method: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Decorator that annotates a method of a behavior as an action.\n\n    Marking a method of a behavior as an action makes the method available\n    to other agents. I.e., peers within a multi-agent system can only invoke\n    methods marked as actions on each other. This enables behaviors to\n    define \"private\" methods.\n\n    Example:\n        ```python\n        from academy.behavior import Behavior, action\n\n        class Example(Behavior):\n            @action\n            def perform(self):\n                ...\n        ```\n    \"\"\"\n    method._agent_method_type = 'action'  # type: ignore[attr-defined]\n    return method\n</code></pre>"},{"location":"api/behavior/#academy.behavior.loop","title":"loop","text":"<pre><code>loop(\n    method: Callable[Concatenate[BehaviorT, P], R],\n) -&gt; Callable[Concatenate[BehaviorT, P], R]\n</code></pre> <p>Decorator that annotates a method of a behavior as a control loop.</p> <p>Control loop methods of a behavior are run as threads when an agent starts. A control loop can run for a well-defined period of time or indefinitely, provided the control loop exits when the <code>shutdown</code> event, passed as a parameter to all control loop methods, is set.</p> Example <pre><code>import threading\nfrom academy.behavior import Behavior, loop\n\nclass Example(Behavior):\n    @loop\n    def listen(self, shutdown: threading.Event) -&gt; None:\n        while not shutdown.is_set():\n            ...\n</code></pre> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if the method signature does not conform to the <code>ControlLoop</code> protocol.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def loop(\n    method: Callable[Concatenate[BehaviorT, P], R],\n) -&gt; Callable[Concatenate[BehaviorT, P], R]:\n    \"\"\"Decorator that annotates a method of a behavior as a control loop.\n\n    Control loop methods of a behavior are run as threads when an agent\n    starts. A control loop can run for a well-defined period of time or\n    indefinitely, provided the control loop exits when the `shutdown`\n    event, passed as a parameter to all control loop methods, is set.\n\n    Example:\n        ```python\n        import threading\n        from academy.behavior import Behavior, loop\n\n        class Example(Behavior):\n            @loop\n            def listen(self, shutdown: threading.Event) -&gt; None:\n                while not shutdown.is_set():\n                    ...\n        ```\n\n    Raises:\n        TypeError: if the method signature does not conform to the\n            [`ControlLoop`][academy.behavior.ControlLoop] protocol.\n    \"\"\"\n    method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n    if sys.version_info &gt;= (3, 10):  # pragma: &gt;=3.10 cover\n        found_sig = inspect.signature(method, eval_str=True)\n        expected_sig = inspect.signature(ControlLoop.__call__, eval_str=True)\n    else:  # pragma: &lt;3.10 cover\n        found_sig = inspect.signature(method)\n        expected_sig = inspect.signature(ControlLoop.__call__)\n\n    if found_sig != expected_sig:\n        raise TypeError(\n            f'Signature of loop method \"{method.__name__}\" is {found_sig} '\n            f'but should be {expected_sig}. If the signatures look the same '\n            'except that types are stringified, try importing '\n            '\"from __future__ import annotations\" at the top of the module '\n            'where the behavior is defined.',\n        )\n\n    @functools.wraps(method)\n    def _wrapped(self: BehaviorT, *args: P.args, **kwargs: P.kwargs) -&gt; R:\n        logger.debug('Started %r loop for %s', method.__name__, self)\n        result = method(self, *args, **kwargs)\n        logger.debug('Exited %r loop for %s', method.__name__, self)\n        return result\n\n    return _wrapped\n</code></pre>"},{"location":"api/behavior/#academy.behavior.event","title":"event","text":"<pre><code>event(\n    name: str,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, Event], None],\n]\n</code></pre> <p>Decorator that annotates a method of a behavior as an event loop.</p> <p>An event loop is a special type of control loop that runs when a <code>threading.Event</code> is set. The event is cleared after the loop runs.</p> Example <pre><code>import threading\nfrom academy.behavior import Behavior, timer\n\nclass Example(Behavior):\n    def __init__(self) -&gt; None:\n        self.alert = threading.Event()\n\n    @event('alert')\n    def handle(self) -&gt; None:\n        # Runs every time alter is set\n        ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name of the <code>threading.Event</code> to wait on.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>Raised at runtime if no attribute named <code>name</code> exists on the behavior.</p> </li> <li> <code>TypeError</code>             \u2013            <p>Raised at runtime if the attribute named <code>name</code> is not a <code>threading.Event</code>.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def event(\n    name: str,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, threading.Event], None],\n]:\n    \"\"\"Decorator that annotates a method of a behavior as an event loop.\n\n    An event loop is a special type of control loop that runs when a\n    [`threading.Event`][threading.Event] is set. The event is cleared\n    after the loop runs.\n\n    Example:\n        ```python\n        import threading\n        from academy.behavior import Behavior, timer\n\n        class Example(Behavior):\n            def __init__(self) -&gt; None:\n                self.alert = threading.Event()\n\n            @event('alert')\n            def handle(self) -&gt; None:\n                # Runs every time alter is set\n                ...\n        ```\n\n    Args:\n        name: Attribute name of the [`threading.Event`][threading.Event]\n            to wait on.\n\n    Raises:\n        AttributeError: Raised at runtime if no attribute named `name`\n            exists on the behavior.\n        TypeError: Raised at runtime if the attribute named `name` is not\n            a [`threading.Event`][threading.Event].\n    \"\"\"\n\n    def decorator(\n        method: Callable[[BehaviorT], None],\n    ) -&gt; Callable[[BehaviorT, threading.Event], None]:\n        method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n        @functools.wraps(method)\n        def _wrapped(self: BehaviorT, shutdown: threading.Event) -&gt; None:\n            event = getattr(self, name)\n            if not isinstance(event, threading.Event):\n                raise TypeError(\n                    f'Attribute {name} of {type(self).__class__} has type '\n                    f'{type(event).__class__}. Expected threading.Event.',\n                )\n\n            logger.debug(\n                'Started %r event loop for %s (event: %r)',\n                method.__name__,\n                self,\n                name,\n            )\n            combined = or_event(shutdown, event)\n            while True:\n                combined.wait()\n                if shutdown.is_set():\n                    break\n                elif event.is_set():\n                    try:\n                        method(self)\n                    finally:\n                        event.clear()\n                else:\n                    raise AssertionError('Unreachable.')\n            logger.debug('Exited %r event loop for %s', method.__name__, self)\n\n        return _wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/behavior/#academy.behavior.timer","title":"timer","text":"<pre><code>timer(\n    interval: float | timedelta,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, Event], None],\n]\n</code></pre> <p>Decorator that annotates a method of a behavior as a timer loop.</p> <p>A timer loop is a special type of control loop that runs at a set interval. The method will always be called once before the first sleep.</p> Example <pre><code>from academy.behavior import Behavior, timer\n\nclass Example(Behavior):\n    @timer(interval=1)\n    def listen(self) -&gt; None:\n        # Runs every 1 second\n        ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>interval</code>               (<code>float | timedelta</code>)           \u2013            <p>Seconds or a <code>timedelta</code> to wait between invoking the method.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def timer(\n    interval: float | timedelta,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, threading.Event], None],\n]:\n    \"\"\"Decorator that annotates a method of a behavior as a timer loop.\n\n    A timer loop is a special type of control loop that runs at a set\n    interval. The method will always be called once before the first\n    sleep.\n\n    Example:\n        ```python\n        from academy.behavior import Behavior, timer\n\n        class Example(Behavior):\n            @timer(interval=1)\n            def listen(self) -&gt; None:\n                # Runs every 1 second\n                ...\n        ```\n\n    Args:\n        interval: Seconds or a [`timedelta`][datetime.timedelta] to wait\n            between invoking the method.\n    \"\"\"\n    interval = (\n        interval.total_seconds()\n        if isinstance(interval, timedelta)\n        else interval\n    )\n\n    def decorator(\n        method: Callable[[BehaviorT], None],\n    ) -&gt; Callable[[BehaviorT, threading.Event], None]:\n        method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n        @functools.wraps(method)\n        def _wrapped(self: BehaviorT, shutdown: threading.Event) -&gt; None:\n            logger.debug(\n                'Started %r timer loop for %s (interval: %fs)',\n                method.__name__,\n                self,\n                interval,\n            )\n            while not shutdown.wait(interval):\n                method(self)\n            logger.debug('Exited %r timer loop for %s', method.__name__, self)\n\n        return _wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/event/","title":"academy.event","text":"<code>academy/event.py</code>"},{"location":"api/event/#academy.event.or_event","title":"or_event","text":"<pre><code>or_event(*events: Event) -&gt; Event\n</code></pre> <p>Create a combined event that is set when any input events are set.</p> Note <p>The creator can wait on the combined event, but must still check each individual event to see which was set.</p> Warning <p>This works by dynamically replacing methods on the inputs events with custom methods that trigger callbacks.</p> Note <p>Based on this Stack Overflow answer.</p> <p>Parameters:</p> <ul> <li> <code>events</code>               (<code>Event</code>, default:                   <code>()</code> )           \u2013            <p>One or more events to combine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A single event that is set when any of the input events is set.</p> </li> </ul> Source code in <code>academy/event.py</code> <pre><code>def or_event(*events: threading.Event) -&gt; threading.Event:\n    \"\"\"Create a combined event that is set when any input events are set.\n\n    Note:\n        The creator can wait on the combined event, but must still check\n        each individual event to see which was set.\n\n    Warning:\n        This works by dynamically replacing methods on the inputs events\n        with custom methods that trigger callbacks.\n\n    Note:\n        Based on this Stack Overflow\n        [answer](https://stackoverflow.com/a/12320352).\n\n    Args:\n        events: One or more events to combine.\n\n    Returns:\n        A single event that is set when any of the input events is set.\n    \"\"\"\n    combined = threading.Event()\n\n    def changed() -&gt; None:\n        bools = [e.is_set() for e in events]\n        if any(bools):\n            combined.set()\n        else:\n            combined.clear()\n\n    for e in events:\n        _orify(e, changed)\n\n    changed()\n    return combined\n</code></pre>"},{"location":"api/exception/","title":"academy.exception","text":"<code>academy/exception.py</code>"},{"location":"api/exception/#academy.exception.BadEntityIdError","title":"BadEntityIdError","text":"<pre><code>BadEntityIdError(uid: EntityId)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Entity associated with the identifier is unknown.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: EntityId) -&gt; None:\n    super().__init__(f'Unknown identifier {uid}.')\n</code></pre>"},{"location":"api/exception/#academy.exception.HandleClosedError","title":"HandleClosedError","text":"<pre><code>HandleClosedError(\n    agent_id: AgentId[Any], mailbox_id: EntityId | None\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Agent handle has been closed.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(\n    self,\n    agent_id: AgentId[Any],\n    mailbox_id: EntityId | None,\n) -&gt; None:\n    message = (\n        f'Handle to {agent_id} bound to {mailbox_id} has been closed.'\n        if mailbox_id is not None\n        else f'Handle to {agent_id} has been closed.'\n    )\n    super().__init__(message)\n</code></pre>"},{"location":"api/exception/#academy.exception.HandleNotBoundError","title":"HandleNotBoundError","text":"<pre><code>HandleNotBoundError(aid: AgentId[Any])\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Handle to agent is in an unbound state.</p> <p>An unbound handle (typically, an instance of <code>UnboundRemoteHandle</code>) is initialized with a target agent ID and exchange, but does not have an identifier itself. Thus, the handle does not have a mailbox in the exchange to receive response messages.</p> <p>A handle must be bound to be used, either as a unique client with its own mailbox or as bound to a running agent where it shares a mailbox with that running agent. To create a client bound handle, use <code>handle.bind_as_client()</code>.</p> <p>Any agent behavior that has a handle to another agent as an instance attribute will be automatically bound to the agent when the agent begins running.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, aid: AgentId[Any]) -&gt; None:\n    super().__init__(\n        f'Handle to {aid} is not bound as a client nor to a running '\n        'agent. See the exception docstring for troubleshooting.',\n    )\n</code></pre>"},{"location":"api/exception/#academy.exception.MailboxClosedError","title":"MailboxClosedError","text":"<pre><code>MailboxClosedError(uid: EntityId)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Mailbox is closed and cannot send or receive messages.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: EntityId) -&gt; None:\n    super().__init__(f'Mailbox for {uid} has been closed.')\n</code></pre>"},{"location":"api/handle/","title":"academy.handle","text":"<code>academy/handle.py</code>"},{"location":"api/handle/#academy.handle.Handle","title":"Handle","text":"<p>               Bases: <code>Protocol[BehaviorT]</code></p> <p>Agent handle protocol.</p> <p>A handle enables a client or agent to invoke actions on another agent.</p>"},{"location":"api/handle/#academy.handle.Handle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.HandleDict","title":"HandleDict","text":"<pre><code>HandleDict(\n    values: (\n        Mapping[K, Handle[BehaviorT]]\n        | Iterable[tuple[K, Handle[BehaviorT]]]\n    ) = (),\n    /,\n    **kwargs: dict[str, Handle[BehaviorT]],\n)\n</code></pre> <p>               Bases: <code>dict[K, Handle[BehaviorT]]</code></p> <p>Dictionary mapping keys to handles.</p> Tip <p>The <code>HandleDict</code> is required when storing a mapping of handles as attributes of a <code>Behavior</code> so that those handles get bound to the correct agent when running.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    values: Mapping[K, Handle[BehaviorT]]\n    | Iterable[tuple[K, Handle[BehaviorT]]] = (),\n    /,\n    **kwargs: dict[str, Handle[BehaviorT]],\n) -&gt; None:\n    super().__init__(values, **kwargs)\n</code></pre>"},{"location":"api/handle/#academy.handle.HandleList","title":"HandleList","text":"<pre><code>HandleList(iterable: Iterable[Handle[BehaviorT]] = ())\n</code></pre> <p>               Bases: <code>list[Handle[BehaviorT]]</code></p> <p>List of handles.</p> Tip <p>The <code>HandleList</code> is required when storing a list of handles as attributes of a <code>Behavior</code> so that those handles get bound to the correct agent when running.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    iterable: Iterable[Handle[BehaviorT]] = (),\n    /,\n) -&gt; None:\n    super().__init__(iterable)\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle","title":"ProxyHandle","text":"<pre><code>ProxyHandle(behavior: BehaviorT)\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code></p> <p>Proxy handle.</p> <p>A proxy handle is thin wrapper around a <code>Behavior</code> instance that is useful for testing behaviors that are initialized with a handle to another agent without needing to spawn agents. This wrapper invokes actions synchronously.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(self, behavior: BehaviorT) -&gt; None:\n    self.behavior = behavior\n    self.agent_id: AgentId[BehaviorT] = AgentId.new()\n    self.mailbox_id: EntityId | None = None\n    self._agent_closed = False\n    self._handle_closed = False\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self._agent_closed:\n        raise MailboxClosedError(self.agent_id)\n    elif self._handle_closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    future: Future[R] = Future()\n    try:\n        method = getattr(self.behavior, action)\n        result = method(*args, **kwargs)\n    except Exception as e:\n        future.set_exception(e)\n    else:\n        future.set_result(result)\n    return future\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> Note <p>This is a no-op for proxy handles.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Note:\n        This is a no-op for proxy handles.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    self._handle_closed = True\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> Note <p>This is a no-op for proxy handles and returns 0 latency.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Note:\n        This is a no-op for proxy handles and returns 0 latency.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self._agent_closed:\n        raise MailboxClosedError(self.agent_id)\n    elif self._handle_closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n    return 0\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self._agent_closed:\n        raise MailboxClosedError(self.agent_id)\n    elif self._handle_closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n    self._agent_closed = True\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle","title":"RemoteHandle","text":"<pre><code>RemoteHandle(\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n    mailbox_id: EntityId | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code>, <code>ABC</code></p> <p>Handle to a remote agent.</p> <p>This is an abstract base class with three possible concrete types representing the three remote handle states: unbound, client bound, or mailbox bound.</p> <p>An unbound handle does not have a mailbox for itself which means it cannot send messages to the remote agent because the handle does not know the return address to use. Thus, unbound handles need to be bound with <code>bind_as_client</code> or <code>bind_to_mailbox</code> before they can be used.</p> <p>A client bound handle has a unique handle identifier and mailbox for itself. A mailbox bound handle shares its identifier and mailbox with another entity (e.g., a running agent).</p> Note <p>When an instance is pickled and unpickled, such as when communicated along with an agent dispatched to run in another process, the handle will be unpickled into an <code>UnboundRemoteHandle</code>. Thus, the handle will need to be bound before use.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Message exchange used for agent communication.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the target agent of this handle.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>EntityId of the mailbox this handle receives messages to. If unbound, this is <code>None</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n    mailbox_id: EntityId | None = None,\n) -&gt; None:\n    self.exchange = exchange\n    self.agent_id = agent_id\n    self.mailbox_id = mailbox_id\n    # Unique identifier for each handle object; used to disambiguate\n    # messages when multiple handles are bound to the same mailbox.\n    self.handle_id = uuid.uuid4()\n\n    self._futures: dict[uuid.UUID, Future[Any]] = {}\n    self._closed = False\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle.bind_as_client","title":"bind_as_client  <code>abstractmethod</code>","text":"<pre><code>bind_as_client(\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle as a unique client in the exchange.</p> Note <p>This is an abstract method. Each remote handle variant implements different semantics.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>ClientId | None</code>, default:                   <code>None</code> )           \u2013            <p>Client identifier to be used by this handle. If <code>None</code>, a new identifier will be created using the exchange.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the client identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>@abc.abstractmethod\ndef bind_as_client(\n    self,\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle as a unique client in the exchange.\n\n    Note:\n        This is an abstract method. Each remote handle variant implements\n        different semantics.\n\n    Args:\n        client_id: Client identifier to be used by this handle. If `None`,\n            a new identifier will be created using the exchange.\n\n    Returns:\n        Remote handle bound to the client identifier.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle.bind_to_mailbox","title":"bind_to_mailbox  <code>abstractmethod</code>","text":"<pre><code>bind_to_mailbox(\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox to bind to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>@abc.abstractmethod\ndef bind_to_mailbox(\n    self,\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle to an existing mailbox.\n\n    Args:\n        mailbox_id: EntityId of the mailbox to bind to.\n\n    Returns:\n        Remote handle bound to the identifier.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    self._closed = True\n\n    if len(self._futures) == 0:\n        return\n    if wait_futures:\n        logger.debug('Waiting on pending futures for %s', self)\n        wait(list(self._futures.values()), timeout=timeout)\n    else:\n        logger.debug('Cancelling pending futures for %s', self)\n        for future in self._futures:\n            self._futures[future].cancel()\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ActionRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        action=action,\n        pargs=args,\n        kargs=kwargs,\n    )\n    future: Future[R] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug(\n        'Sent action request from %s to %s (action=%r)',\n        self.mailbox_id,\n        self.agent_id,\n        action,\n    )\n    return future\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    start = time.perf_counter()\n    request = PingRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    future: Future[None] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug('Sent ping from %s to %s', self.mailbox_id, self.agent_id)\n    future.result(timeout=timeout)\n    elapsed = time.perf_counter() - start\n    logger.debug(\n        'Received ping from %s to %s in %.1f ms',\n        self.mailbox_id,\n        self.agent_id,\n        elapsed * 1000,\n    )\n    return elapsed\n</code></pre>"},{"location":"api/handle/#academy.handle.RemoteHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ShutdownRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    self._send_request(request)\n    logger.debug(\n        'Sent shutdown request from %s to %s',\n        self.mailbox_id,\n        self.agent_id,\n    )\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle","title":"UnboundRemoteHandle","text":"<pre><code>UnboundRemoteHandle(\n    exchange: Exchange, agent_id: AgentId[BehaviorT]\n)\n</code></pre> <p>               Bases: <code>RemoteHandle[BehaviorT]</code></p> <p>Handle to a remote agent that is unbound.</p> Warning <p>An unbound handle must be bound before use. Otherwise all methods will raise an <code>HandleNotBoundError</code> when attempting to send a message to the remote agent.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Message exchange used for agent communication.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n) -&gt; None:\n    super().__init__(exchange, agent_id=agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle as a unique client in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>ClientId | None</code>, default:                   <code>None</code> )           \u2013            <p>Client identifier to be used by this handle. If <code>None</code>, a new identifier will be created using the exchange.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the client identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_as_client(\n    self,\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle as a unique client in the exchange.\n\n    Args:\n        client_id: Client identifier to be used by this handle. If `None`,\n            a new identifier will be created using the exchange.\n\n    Returns:\n        Remote handle bound to the client identifier.\n    \"\"\"\n    return ClientRemoteHandle(self.exchange, self.agent_id, client_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.bind_to_mailbox","title":"bind_to_mailbox","text":"<pre><code>bind_to_mailbox(\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox to bind to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_to_mailbox(\n    self,\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle to an existing mailbox.\n\n    Args:\n        mailbox_id: EntityId of the mailbox to bind to.\n\n    Returns:\n        Remote handle bound to the identifier.\n    \"\"\"\n    return BoundRemoteHandle(self.exchange, self.agent_id, mailbox_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    self._closed = True\n\n    if len(self._futures) == 0:\n        return\n    if wait_futures:\n        logger.debug('Waiting on pending futures for %s', self)\n        wait(list(self._futures.values()), timeout=timeout)\n    else:\n        logger.debug('Cancelling pending futures for %s', self)\n        for future in self._futures:\n            self._futures[future].cancel()\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle","title":"BoundRemoteHandle","text":"<pre><code>BoundRemoteHandle(\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n    mailbox_id: EntityId,\n)\n</code></pre> <p>               Bases: <code>RemoteHandle[BehaviorT]</code></p> <p>Handle to a remote agent bound to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Message exchange used for agent communication.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the target agent of this handle.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox this handle receives messages to.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n    mailbox_id: EntityId,\n) -&gt; None:\n    if agent_id == mailbox_id:\n        raise ValueError(\n            f'Cannot create handle to {agent_id} that is bound to itself. '\n            'Check that the values of `agent_id` and `mailbox_id` '\n            'are different.',\n        )\n    super().__init__(exchange, agent_id, mailbox_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle as a unique client in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>ClientId | None</code>, default:                   <code>None</code> )           \u2013            <p>Client identifier to be used by this handle. If <code>None</code>, a new identifier will be created using the exchange.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the client identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_as_client(\n    self,\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle as a unique client in the exchange.\n\n    Args:\n        client_id: Client identifier to be used by this handle. If `None`,\n            a new identifier will be created using the exchange.\n\n    Returns:\n        Remote handle bound to the client identifier.\n    \"\"\"\n    return ClientRemoteHandle(self.exchange, self.agent_id, client_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.bind_to_mailbox","title":"bind_to_mailbox","text":"<pre><code>bind_to_mailbox(\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox to bind to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_to_mailbox(\n    self,\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle to an existing mailbox.\n\n    Args:\n        mailbox_id: EntityId of the mailbox to bind to.\n\n    Returns:\n        Remote handle bound to the identifier.\n    \"\"\"\n    if mailbox_id == self.mailbox_id:\n        return self\n    else:\n        return BoundRemoteHandle(self.exchange, self.agent_id, mailbox_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    super().close(wait_futures, timeout=timeout)\n    logger.debug('Closed handle (%s)', self)\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ActionRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        action=action,\n        pargs=args,\n        kargs=kwargs,\n    )\n    future: Future[R] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug(\n        'Sent action request from %s to %s (action=%r)',\n        self.mailbox_id,\n        self.agent_id,\n        action,\n    )\n    return future\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    start = time.perf_counter()\n    request = PingRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    future: Future[None] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug('Sent ping from %s to %s', self.mailbox_id, self.agent_id)\n    future.result(timeout=timeout)\n    elapsed = time.perf_counter() - start\n    logger.debug(\n        'Received ping from %s to %s in %.1f ms',\n        self.mailbox_id,\n        self.agent_id,\n        elapsed * 1000,\n    )\n    return elapsed\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ShutdownRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    self._send_request(request)\n    logger.debug(\n        'Sent shutdown request from %s to %s',\n        self.mailbox_id,\n        self.agent_id,\n    )\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle","title":"ClientRemoteHandle","text":"<pre><code>ClientRemoteHandle(\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n    client_id: ClientId | None = None,\n)\n</code></pre> <p>               Bases: <code>RemoteHandle[BehaviorT]</code></p> <p>Handle to a remote agent bound as a unique client.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Message exchange used for agent communication.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the target agent of this handle.</p> </li> <li> <code>client_id</code>               (<code>ClientId | None</code>, default:                   <code>None</code> )           \u2013            <p>Client identifier of this handle. If <code>None</code>, a new identifier will be created using the exchange. Note this will become the <code>mailbox_id</code> attribute of the handle.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    exchange: Exchange,\n    agent_id: AgentId[BehaviorT],\n    client_id: ClientId | None = None,\n) -&gt; None:\n    if client_id is None:\n        client_id = exchange.register_client()\n    super().__init__(exchange, agent_id, client_id)\n    assert self.mailbox_id is not None\n    self._mailbox = self.exchange.get_mailbox(self.mailbox_id)\n    self._recv_thread = threading.Thread(\n        target=self._recv_responses,\n        name=f'{self}-message-handler',\n    )\n    self._recv_thread.start()\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle as a unique client in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>ClientId | None</code>, default:                   <code>None</code> )           \u2013            <p>Client identifier to be used by this handle. If <code>None</code> or equal to this handle's ID, self will be returned. Otherwise, a new identifier will be created using the exchange.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the client identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_as_client(\n    self,\n    client_id: ClientId | None = None,\n) -&gt; ClientRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle as a unique client in the exchange.\n\n    Args:\n        client_id: Client identifier to be used by this handle. If `None`\n            or equal to this handle's ID, self will be returned. Otherwise,\n            a new identifier will be created using the exchange.\n\n    Returns:\n        Remote handle bound to the client identifier.\n    \"\"\"\n    if client_id is None or client_id == self.mailbox_id:\n        return self\n    else:\n        return ClientRemoteHandle(self.exchange, self.agent_id, client_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle.bind_to_mailbox","title":"bind_to_mailbox","text":"<pre><code>bind_to_mailbox(\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox to bind to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_to_mailbox(\n    self,\n    mailbox_id: EntityId,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle to an existing mailbox.\n\n    Args:\n        mailbox_id: EntityId of the mailbox to bind to.\n\n    Returns:\n        Remote handle bound to the identifier.\n    \"\"\"\n    return BoundRemoteHandle(self.exchange, self.agent_id, mailbox_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>if the response message listener thread is not alive when <code>close()</code> is called indicating the listener thread likely crashed.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n\n    Raises:\n        RuntimeError: if the response message listener thread is not alive\n            when `close()` is called indicating the listener thread likely\n            crashed.\n    \"\"\"\n    super().close(wait_futures, timeout=timeout)\n\n    assert isinstance(self.mailbox_id, ClientId)\n    if not self._recv_thread.is_alive():\n        raise RuntimeError(\n            f'Result message listener for {self.mailbox_id} is not alive. '\n            'This likely means the listener thread crashed.',\n        )\n\n    self.exchange.terminate(self.mailbox_id)\n    timeout = 5\n    self._recv_thread.join(timeout=timeout)\n    if self._recv_thread.is_alive():  # pragma: no cover\n        raise TimeoutError(\n            f'Result message listener for {self.mailbox_id} did '\n            f'not exit within {timeout} seconds.',\n        )\n    self._mailbox.close()\n\n    logger.debug('Closed handle (%s)', self)\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ActionRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        action=action,\n        pargs=args,\n        kargs=kwargs,\n    )\n    future: Future[R] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug(\n        'Sent action request from %s to %s (action=%r)',\n        self.mailbox_id,\n        self.agent_id,\n        action,\n    )\n    return future\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    start = time.perf_counter()\n    request = PingRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    future: Future[None] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug('Sent ping from %s to %s', self.mailbox_id, self.agent_id)\n    future.result(timeout=timeout)\n    elapsed = time.perf_counter() - start\n    logger.debug(\n        'Received ping from %s to %s in %.1f ms',\n        self.mailbox_id,\n        self.agent_id,\n        elapsed * 1000,\n    )\n    return elapsed\n</code></pre>"},{"location":"api/handle/#academy.handle.ClientRemoteHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ShutdownRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    self._send_request(request)\n    logger.debug(\n        'Sent shutdown request from %s to %s',\n        self.mailbox_id,\n        self.agent_id,\n    )\n</code></pre>"},{"location":"api/identifier/","title":"academy.identifier","text":"<code>academy/identifier.py</code>"},{"location":"api/identifier/#academy.identifier.EntityId","title":"EntityId  <code>module-attribute</code>","text":"<pre><code>EntityId = Union[AgentId[Any], ClientId]\n</code></pre> <p>EntityId union type for type annotations.</p>"},{"location":"api/identifier/#academy.identifier.AgentId","title":"AgentId  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[BehaviorT]</code></p> <p>Unique identifier of an agent in a multi-agent system.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>role</code>                 (<code>Literal['agent']</code>)             </li> </ul>"},{"location":"api/identifier/#academy.identifier.AgentId.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(name: str | None = None) -&gt; Self\n</code></pre> <p>Create a new identifier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the entity.</p> </li> </ul> Source code in <code>academy/identifier.py</code> <pre><code>@classmethod\ndef new(cls, name: str | None = None) -&gt; Self:\n    \"\"\"Create a new identifier.\n\n    Args:\n        name: Optional human-readable name for the entity.\n    \"\"\"\n    return cls(uid=uuid.uuid4(), name=name)\n</code></pre>"},{"location":"api/identifier/#academy.identifier.ClientId","title":"ClientId  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Unique identifier of a client in a multi-agent system.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>role</code>                 (<code>Literal['client']</code>)             </li> </ul>"},{"location":"api/identifier/#academy.identifier.ClientId.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(name: str | None = None) -&gt; Self\n</code></pre> <p>Create a new identifier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the entity.</p> </li> </ul> Source code in <code>academy/identifier.py</code> <pre><code>@classmethod\ndef new(cls, name: str | None = None) -&gt; Self:\n    \"\"\"Create a new identifier.\n\n    Args:\n        name: Optional human-readable name for the entity.\n    \"\"\"\n    return cls(uid=uuid.uuid4(), name=name)\n</code></pre>"},{"location":"api/logging/","title":"academy.logging","text":"<code>academy/logging.py</code>"},{"location":"api/logging/#academy.logging.init_logging","title":"init_logging","text":"<pre><code>init_logging(\n    level: int | str = INFO,\n    *,\n    logfile: str | Path | None = None,\n    logfile_level: int | str | None = None,\n    color: bool = True,\n    extra: bool = False,\n    force: bool = False\n) -&gt; Logger\n</code></pre> <p>Initialize global logger.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>INFO</code> )           \u2013            <p>Minimum logging level.</p> </li> <li> <code>logfile</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Configure a file handler for this path.</p> </li> <li> <code>logfile_level</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Minimum logging level for the file handler. Defaults to that of <code>level</code>.</p> </li> <li> <code>color</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use colorful logging for stdout.</p> </li> <li> <code>extra</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Include extra info in log messages, such as thread ID and process ID. This is helpful for debugging.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Remove any existing handlers attached to the root handler. This option is useful to silencing the third-party package logging. Note: should not be set when running inside pytest.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Logger</code>           \u2013            <p>The root logger.</p> </li> </ul> Source code in <code>academy/logging.py</code> <pre><code>def init_logging(  # noqa: PLR0913\n    level: int | str = logging.INFO,\n    *,\n    logfile: str | pathlib.Path | None = None,\n    logfile_level: int | str | None = None,\n    color: bool = True,\n    extra: bool = False,\n    force: bool = False,\n) -&gt; logging.Logger:\n    \"\"\"Initialize global logger.\n\n    Args:\n        level: Minimum logging level.\n        logfile: Configure a file handler for this path.\n        logfile_level: Minimum logging level for the file handler. Defaults\n            to that of `level`.\n        color: Use colorful logging for stdout.\n        extra: Include extra info in log messages, such as thread ID and\n            process ID. This is helpful for debugging.\n        force: Remove any existing handlers attached to the root\n            handler. This option is useful to silencing the third-party\n            package logging. Note: should not be set when running inside\n            pytest.\n\n    Returns:\n        The root logger.\n    \"\"\"\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setFormatter(_Formatter(color=color, extra=extra))\n    stdout_handler.setLevel(level)\n    if extra:\n        stdout_handler.addFilter(_os_thread_filter)\n    handlers: list[logging.Handler] = [stdout_handler]\n\n    if logfile is not None:\n        logfile_level = level if logfile_level is None else logfile_level\n        path = pathlib.Path(logfile)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        handler = logging.FileHandler(path)\n        handler.setFormatter(_Formatter(color=False, extra=extra))\n        handler.setLevel(logfile_level)\n        handlers.append(handler)\n\n    logging.basicConfig(\n        datefmt='%Y-%m-%d %H:%M:%S',\n        level=logging.NOTSET,\n        handlers=handlers,\n        force=force,\n    )\n\n    # This needs to be after the configuration of the root logger because\n    # warnings get logged to a 'py.warnings' logger.\n    logging.captureWarnings(True)\n\n    logger = logging.getLogger()\n    logger.info(\n        'Configured logger (stdout-level=%s, logfile=%s, logfile-level=%s)',\n        logging.getLevelName(level) if isinstance(level, int) else level,\n        logfile,\n        logging.getLevelName(logfile_level)\n        if isinstance(logfile_level, int)\n        else logfile_level,\n    )\n\n    return logger\n</code></pre>"},{"location":"api/manager/","title":"academy.manager","text":"<code>academy/manager.py</code>"},{"location":"api/manager/#academy.manager.Manager","title":"Manager","text":"<pre><code>Manager(\n    exchange: Exchange,\n    launcher: Launcher | MutableMapping[str, Launcher],\n    *,\n    default_launcher: str | None = None\n)\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Launch and manage running agents.</p> <p>The manager is provided as convenience to reduce common boilerplate code for spawning agents and managing handles. Each manager registers itself as a client in the exchange (i.e., each manager has its own mailbox). Handles created by the manager are bound to this mailbox.</p> Tip <p>This class can be used as a context manager. Upon exiting the context, running agents will be shutdown, any agent handles created by the manager will be closed, and the exchange and launcher will be closed.</p> Note <p>The manager takes ownership of the exchange and launcher interfaces. This means the manager will be responsible for closing them once the manager is closed.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Exchange that agents and clients will use for communication.</p> </li> <li> <code>launcher</code>               (<code>Launcher | MutableMapping[str, Launcher]</code>)           \u2013            <p>A mapping of names to launchers used to execute agents remotely. If a single launcher is provided directly, it is set as the default with name <code>'default'</code>, overriding any value of <code>default_launcher</code>.</p> </li> <li> <code>default_launcher</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the name of the default launcher to use when not specified in <code>launch()</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>default_launcher</code> is specified but does not exist in <code>launchers</code>.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def __init__(\n    self,\n    exchange: Exchange,\n    launcher: Launcher | MutableMapping[str, Launcher],\n    *,\n    default_launcher: str | None = None,\n) -&gt; None:\n    if isinstance(launcher, Launcher):\n        launcher = {'default': launcher}\n        default_launcher = 'default'\n\n    if default_launcher is not None and default_launcher not in launcher:\n        raise ValueError(\n            f'No launcher named \"{default_launcher}\" was provided to '\n            'use as the default.',\n        )\n\n    self._exchange = exchange\n    self._launchers = launcher\n    self._default_launcher = default_launcher\n\n    self._mailbox_id = exchange.register_client()\n    self._multiplexer = MailboxMultiplexer(\n        self.mailbox_id,\n        self._exchange,\n        self._handle_request,\n    )\n    self._handles: dict[AgentId[Any], BoundRemoteHandle[Any]] = {}\n    self._aid_to_launcher: dict[AgentId[Any], str] = {}\n    self._listener_thread = threading.Thread(\n        target=self._multiplexer.listen,\n        name=f'multiplexer-{self.mailbox_id.uid}-listener',\n    )\n    self._listener_thread.start()\n    logger.info(\n        'Initialized manager (%s; %s)',\n        self._mailbox_id,\n        self._exchange,\n    )\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: Exchange\n</code></pre> <p>Exchange interface.</p>"},{"location":"api/manager/#academy.manager.Manager.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: ClientId\n</code></pre> <p>EntityId of the mailbox used by this manager.</p>"},{"location":"api/manager/#academy.manager.Manager.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the manager and cleanup resources.</p> <ol> <li>Call shutdown on all running agents.</li> <li>Close all handles created by the manager.</li> <li>Close the mailbox associated with the manager.</li> <li>Close the exchange.</li> <li>Close all launchers.</li> </ol> Source code in <code>academy/manager.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the manager and cleanup resources.\n\n    1. Call shutdown on all running agents.\n    1. Close all handles created by the manager.\n    1. Close the mailbox associated with the manager.\n    1. Close the exchange.\n    1. Close all launchers.\n    \"\"\"\n    for launcher in self._launchers.values():\n        for agent_id in launcher.running():\n            handle = self._handles[agent_id]\n            with contextlib.suppress(MailboxClosedError):\n                handle.shutdown()\n    logger.debug('Instructed managed agents to shutdown')\n    self._multiplexer.close_bound_handles()\n    self._multiplexer.terminate()\n    self._listener_thread.join()\n    self.exchange.close()\n    for launcher in self._launchers.values():\n        launcher.close()\n    logger.info('Closed manager (%s)', self.mailbox_id)\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.add_launcher","title":"add_launcher","text":"<pre><code>add_launcher(name: str, launcher: Launcher) -&gt; Self\n</code></pre> <p>Add a launcher to the manager.</p> Note <p>It is not possible to remove a launcher as this could create complications if an agent was already launched using a given launcher.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the launcher.</p> </li> <li> <code>launcher</code>               (<code>Launcher</code>)           \u2013            <p>Launcher instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self for chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a launcher with <code>name</code> already exists.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def add_launcher(self, name: str, launcher: Launcher) -&gt; Self:\n    \"\"\"Add a launcher to the manager.\n\n    Note:\n        It is not possible to remove a launcher as this could create\n        complications if an agent was already launched using a given\n        launcher.\n\n    Args:\n        name: Name of the launcher.\n        launcher: Launcher instance.\n\n    Returns:\n        Self for chaining.\n\n    Raises:\n        ValueError: If a launcher with `name` already exists.\n    \"\"\"\n    if name in self._launchers:\n        raise ValueError(f'Launcher named \"{name}\" already exists.')\n    self._launchers[name] = launcher\n    return self\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.set_default_launcher","title":"set_default_launcher","text":"<pre><code>set_default_launcher(name: str | None) -&gt; Self\n</code></pre> <p>Set the name of the default launcher.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>Name of the launcher to default to. If <code>None</code>, no default launcher is set and all calls to <code>launch()</code> must specify the launcher.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self for chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no launcher with <code>name</code> exists.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def set_default_launcher(self, name: str | None) -&gt; Self:\n    \"\"\"Set the name of the default launcher.\n\n    Args:\n        name: Name of the launcher to default to. If `None`, no default\n            launcher is set and all calls to `launch()` must specify\n            the launcher.\n\n    Returns:\n        Self for chaining.\n\n    Raises:\n        ValueError: If no launcher with `name` exists.\n    \"\"\"\n    if name not in self._launchers:\n        raise ValueError(f'A launcher name \"{name}\" does not exist.')\n    self._default_launcher = name\n    return self\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    launcher: str | None = None,\n    name: str | None = None\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> Note <p>Compared to <code>Launcher.launch()</code>, this method will inject the exchange and return a client-bound handle.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>launcher</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the launcher instance to use. In <code>None</code>, uses the default launcher if specified, otherwise raises an error.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle (client bound) used to interact with the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no default launcher is set and <code>launcher</code> is not specified.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    launcher: str | None = None,\n    name: str | None = None,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Note:\n        Compared to `Launcher.launch()`, this method will inject the\n        exchange and return a client-bound handle.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        launcher: Name of the launcher instance to use. In `None`, uses\n            the default launcher if specified, otherwise raises an error.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Handle (client bound) used to interact with the agent.\n\n    Raises:\n        ValueError: If no default launcher is set and `launcher` is not\n            specified.\n    \"\"\"\n    if self._default_launcher is None and launcher is None:\n        raise ValueError(\n            'Must specify the launcher when no default is set.',\n        )\n    launcher = launcher if launcher is not None else self._default_launcher\n    assert launcher is not None\n    launcher_instance = self._launchers[launcher]\n    unbound = launcher_instance.launch(\n        behavior,\n        exchange=self.exchange,\n        agent_id=agent_id,\n        name=name,\n    )\n    self._aid_to_launcher[unbound.agent_id] = launcher\n    logger.info('Launched agent (%s; %s)', unbound.agent_id, behavior)\n    bound = self._multiplexer.bind(unbound)\n    self._handles[bound.agent_id] = bound\n    logger.debug('Bound agent handle to manager (%s)', bound)\n    return bound\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.shutdown","title":"shutdown","text":"<pre><code>shutdown(\n    agent_id: AgentId[Any],\n    *,\n    blocking: bool = True,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Shutdown a launched agent.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>blocking</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait for the agent to exit before returning.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout is seconds when <code>blocking=True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while blocking for agent.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def shutdown(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    blocking: bool = True,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Shutdown a launched agent.\n\n    Args:\n        agent_id: ID of launched agent.\n        blocking: Wait for the agent to exit before returning.\n        timeout: Optional timeout is seconds when `blocking=True`.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while blocking for agent.\n    \"\"\"\n    try:\n        handle = self._handles[agent_id]\n    except KeyError:\n        raise BadEntityIdError(agent_id) from None\n\n    with contextlib.suppress(MailboxClosedError):\n        handle.shutdown()\n\n    if blocking:\n        self.wait(agent_id, timeout=timeout)\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.wait","title":"wait","text":"<pre><code>wait(\n    agent: AgentId[Any] | RemoteHandle[Any],\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentId[Any] | RemoteHandle[Any]</code>)           \u2013            <p>ID or handle to the launched agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If the agent was not found. This likely means the agent was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def wait(\n    self,\n    agent: AgentId[Any] | RemoteHandle[Any],\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Args:\n        agent: ID or handle to the launched agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If the agent was not found. This likely means\n            the agent was not launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n    \"\"\"\n    agent_id = agent.agent_id if isinstance(agent, RemoteHandle) else agent\n    if agent_id not in self._aid_to_launcher:\n        raise BadEntityIdError(agent_id)\n    launcher_name = self._aid_to_launcher[agent_id]\n    self._launchers[launcher_name].wait(agent_id, timeout=timeout)\n</code></pre>"},{"location":"api/message/","title":"academy.message","text":"<code>academy/message.py</code>"},{"location":"api/message/#academy.message.Message","title":"Message  <code>module-attribute</code>","text":"<pre><code>Message = Union[RequestMessage, ResponseMessage]\n</code></pre> <p>Message union type for type annotations.</p> Tip <p>This is a parameterized generic type meaning that this type cannot be used for [<code>isinstance</code>][<code>builtins.isinstance</code>] checks: <pre><code>isinstance(message, Message)  # Fails\n</code></pre> Instead, use <code>typing.get_args()</code>: <pre><code>from typing import get_args\n\nisinstance(message, get_args(Message))  # Works\n</code></pre></p>"},{"location":"api/message/#academy.message.BaseMessage","title":"BaseMessage  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base message type for messages between entities (agents or clients).</p> Note <p>The <code>hash()</code> of this type is a combination of the message type and message ID.</p> <p>Config:</p> <ul> <li><code>arbitrary_types_allowed</code>: <code>True</code></li> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>False</code></li> <li><code>use_enum_values</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> </ul>"},{"location":"api/message/#academy.message.BaseMessage.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.BaseMessage.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.BaseMessage.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.BaseMessage.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.BaseMessage.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.BaseMessage.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.BaseMessage.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest","title":"ActionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent action request message.</p> <p>When this message is dumped to a JSON string, the <code>pargs</code> and <code>kargs</code> are pickled and then base64 encoded to a string. This can have non-trivial time and space overheads for large arguments.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>action</code>                 (<code>str</code>)             </li> <li> <code>pargs</code>                 (<code>tuple[Any, ...]</code>)             </li> <li> <code>kargs</code>                 (<code>dict[str, Any]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['action-request']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>pargs</code>,                   <code>kargs</code> </li> </ul>"},{"location":"api/message/#academy.message.ActionRequest.action","title":"action  <code>pydantic-field</code>","text":"<pre><code>action: str\n</code></pre> <p>Name of the requested action.</p>"},{"location":"api/message/#academy.message.ActionRequest.pargs","title":"pargs  <code>pydantic-field</code>","text":"<pre><code>pargs: tuple[Any, ...]\n</code></pre> <p>Positional arguments to the action method.</p>"},{"location":"api/message/#academy.message.ActionRequest.kargs","title":"kargs  <code>pydantic-field</code>","text":"<pre><code>kargs: dict[str, Any]\n</code></pre> <p>Keyword arguments to the action method.</p>"},{"location":"api/message/#academy.message.ActionRequest.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ActionRequest.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ActionRequest.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ActionRequest.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ActionRequest.error","title":"error","text":"<pre><code>error(exception: Exception) -&gt; ActionResponse\n</code></pre> <p>Construct an error response to action request.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>Error of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def error(self, exception: Exception) -&gt; ActionResponse:\n    \"\"\"Construct an error response to action request.\n\n    Args:\n        exception: Error of the action.\n    \"\"\"\n    return ActionResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        action=self.action,\n        result=None,\n        exception=exception,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.response","title":"response","text":"<pre><code>response(result: Any) -&gt; ActionResponse\n</code></pre> <p>Construct a success response to action request.</p> <p>Parameters:</p> <ul> <li> <code>result</code>               (<code>Any</code>)           \u2013            <p>Result of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def response(self, result: Any) -&gt; ActionResponse:\n    \"\"\"Construct a success response to action request.\n\n    Args:\n        result: Result of the action.\n    \"\"\"\n    return ActionResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        action=self.action,\n        result=result,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ActionResponse","title":"ActionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent action response message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>action</code>                 (<code>str</code>)             </li> <li> <code>result</code>                 (<code>Any</code>)             </li> <li> <code>exception</code>                 (<code>Optional[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['action-response']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>exception</code>,                   <code>result</code> </li> </ul>"},{"location":"api/message/#academy.message.ActionResponse.action","title":"action  <code>pydantic-field</code>","text":"<pre><code>action: str\n</code></pre> <p>Name of the requested action.</p>"},{"location":"api/message/#academy.message.ActionResponse.result","title":"result  <code>pydantic-field</code>","text":"<pre><code>result: Any = None\n</code></pre> <p>Result of the action, if successful.</p>"},{"location":"api/message/#academy.message.ActionResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: Optional[Exception] = None\n</code></pre> <p>Exception of the action, if unsuccessful.</p>"},{"location":"api/message/#academy.message.ActionResponse.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ActionResponse.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ActionResponse.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ActionResponse.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ActionResponse.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ActionResponse.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ActionResponse.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest","title":"PingRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Ping request message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['ping-request']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.PingRequest.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.PingRequest.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.PingRequest.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.PingRequest.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.PingRequest.response","title":"response","text":"<pre><code>response() -&gt; PingResponse\n</code></pre> <p>Construct a ping response message.</p> Source code in <code>academy/message.py</code> <pre><code>def response(self) -&gt; PingResponse:\n    \"\"\"Construct a ping response message.\"\"\"\n    return PingResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.error","title":"error","text":"<pre><code>error(exception: Exception) -&gt; PingResponse\n</code></pre> <p>Construct an error response to ping request.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>Error of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def error(self, exception: Exception) -&gt; PingResponse:\n    \"\"\"Construct an error response to ping request.\n\n    Args:\n        exception: Error of the action.\n    \"\"\"\n    return PingResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=exception,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.PingResponse","title":"PingResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Ping response message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>exception</code>                 (<code>Optional[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['ping-response']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>exception</code> </li> </ul>"},{"location":"api/message/#academy.message.PingResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: Optional[Exception] = None\n</code></pre> <p>Exception of the ping, if unsuccessful.</p>"},{"location":"api/message/#academy.message.PingResponse.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.PingResponse.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.PingResponse.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.PingResponse.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.PingResponse.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.PingResponse.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.PingResponse.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest","title":"ShutdownRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent shutdown request message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['shutdown-request']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_agent</code>                 \u2192                   <code>dest</code> </li> </ul>"},{"location":"api/message/#academy.message.ShutdownRequest.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.response","title":"response","text":"<pre><code>response() -&gt; ShutdownResponse\n</code></pre> <p>Construct a shutdown response message.</p> Source code in <code>academy/message.py</code> <pre><code>def response(self) -&gt; ShutdownResponse:\n    \"\"\"Construct a shutdown response message.\"\"\"\n    return ShutdownResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.error","title":"error","text":"<pre><code>error(exception: Exception) -&gt; ShutdownResponse\n</code></pre> <p>Construct an error response to shutdown request.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>Error of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def error(self, exception: Exception) -&gt; ShutdownResponse:\n    \"\"\"Construct an error response to shutdown request.\n\n    Args:\n        exception: Error of the action.\n    \"\"\"\n    return ShutdownResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=exception,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownResponse","title":"ShutdownResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent shutdown response message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>exception</code>                 (<code>Optional[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['shutdown-response']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>exception</code> </li> </ul>"},{"location":"api/message/#academy.message.ShutdownResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: Optional[Exception] = None\n</code></pre> <p>Exception of the request, if unsuccessful.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownResponse.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownResponse.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/multiplex/","title":"academy.multiplex","text":"<code>academy/multiplex.py</code>"},{"location":"api/multiplex/#academy.multiplex.MailboxMultiplexer","title":"MailboxMultiplexer","text":"<pre><code>MailboxMultiplexer(\n    mailbox_id: EntityId,\n    exchange: Exchange,\n    request_handler: Callable[[RequestMessage], None],\n)\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Multiplex a single mailbox across many consumers.</p> <p>A mailbox represents a recipient entity. In many cases, there may be many entities within a single process that want to send and receive messages. For example, a running agent may have multiple handles to other agents. A naive approach would be for the agent and each handle to have their own mailbox, but this requires a listening thread in the process for each mailbox. This does not scale well. The multiplexer lets multiple entities (e.g., an agent and its handles) share the a single mailbox so their is one listening thread and messages are dispatched to the appropriate entity (i.e., object) within the process.</p> Note <p>This class should not be considered as a part of the public API. It is used internally by other components, such as the <code>Agent</code> and <code>Manager</code>, which use multiple handles concurrently.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox to multiplex. For example, the identifier of an agent.</p> </li> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>The exchange interface managing the mailbox.</p> </li> <li> <code>request_handler</code>               (<code>Callable[[RequestMessage], None]</code>)           \u2013            <p>A callable invoked when the request message is received to the inbox.</p> </li> </ul> Source code in <code>academy/multiplex.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    exchange: Exchange,\n    request_handler: Callable[[RequestMessage], None],\n) -&gt; None:\n    self.mailbox_id = mailbox_id\n    self.exchange = exchange\n    self.request_handler = request_handler\n    self.bound_handles: dict[uuid.UUID, BoundRemoteHandle[Any]] = {}\n</code></pre>"},{"location":"api/multiplex/#academy.multiplex.MailboxMultiplexer.bind","title":"bind","text":"<pre><code>bind(\n    handle: RemoteHandle[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind a handle to this mailbox.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>RemoteHandle[BehaviorT]</code>)           \u2013            <p>Remote handle to bind.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to this mailbox.</p> </li> </ul> Source code in <code>academy/multiplex.py</code> <pre><code>def bind(\n    self,\n    handle: RemoteHandle[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind a handle to this mailbox.\n\n    Args:\n        handle: Remote handle to bind.\n\n    Returns:\n        Remote handle bound to this mailbox.\n    \"\"\"\n    bound = handle.bind_to_mailbox(self.mailbox_id)\n    self.bound_handles[bound.handle_id] = bound\n    logger.debug(\n        'Bound handle to %s to multiplexer (%s)',\n        bound.agent_id,\n        self,\n    )\n    return bound\n</code></pre>"},{"location":"api/multiplex/#academy.multiplex.MailboxMultiplexer.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the multiplexer.</p> <p>Closes all handles bound to this mailbox and then closes the mailbox.</p> Source code in <code>academy/multiplex.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the multiplexer.\n\n    Closes all handles bound to this mailbox and then closes the mailbox.\n    \"\"\"\n    # This will cause listen() to return\n    self.terminate()\n    self.close_bound_handles()\n</code></pre>"},{"location":"api/multiplex/#academy.multiplex.MailboxMultiplexer.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/multiplex.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n    logger.debug('Closed all handles bound to multiplexer (%s)', self)\n</code></pre>"},{"location":"api/multiplex/#academy.multiplex.MailboxMultiplexer.terminate","title":"terminate","text":"<pre><code>terminate() -&gt; None\n</code></pre> <p>Close the mailbox.</p> Source code in <code>academy/multiplex.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"Close the mailbox.\"\"\"\n    self.exchange.terminate(self.mailbox_id)\n    logger.debug('Closed mailbox of multiplexer (%s)', self)\n</code></pre>"},{"location":"api/multiplex/#academy.multiplex.MailboxMultiplexer.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/multiplex.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    logger.debug('Listening for messages in %s', self)\n    mailbox = self.exchange.get_mailbox(self.mailbox_id)\n\n    try:\n        while True:\n            message = mailbox.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n    finally:\n        mailbox.close()\n        logger.debug('Finished listening for messages in %s', self)\n</code></pre>"},{"location":"api/serialize/","title":"academy.serialize","text":"<code>academy/serialize.py</code>"},{"location":"api/serialize/#academy.serialize.NoPickleMixin","title":"NoPickleMixin","text":"<p>Mixin that raises an error if a type is pickled.</p>"},{"location":"api/socket/","title":"academy.socket","text":"<code>academy/socket.py</code>"},{"location":"api/socket/#academy.socket.SocketClosedError","title":"SocketClosedError","text":"<p>               Bases: <code>Exception</code></p> <p>Socket is already closed.</p>"},{"location":"api/socket/#academy.socket.SocketOpenError","title":"SocketOpenError","text":"<p>               Bases: <code>Exception</code></p> <p>Failed to open socket.</p>"},{"location":"api/socket/#academy.socket.SimpleSocket","title":"SimpleSocket","text":"<pre><code>SimpleSocket(\n    host: str, port: int, *, timeout: float | None = None\n)\n</code></pre> <p>Simple socket wrapper.</p> <p>Configures a client connection using a blocking TCP socket over IPv4. The send and recv methods handle byte encoding, message delimiters, and partial message buffering.</p> Note <p>This class can be used as a context manager.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host address to connect to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port to connect to.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection establish timeout.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketOpenError</code>             \u2013            <p>if creating the socket fails. The <code>__cause__</code> of the exception will be set to the underlying <code>OSError</code>.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    self.host = host\n    self.port = port\n    self.timeout = timeout\n    self.closed = False\n    try:\n        self.socket = socket.create_connection(\n            (self.host, self.port),\n            timeout=self.timeout,\n        )\n    except OSError as e:\n        raise SocketOpenError() from e\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.close","title":"close","text":"<pre><code>close(shutdown: bool = True) -&gt; None\n</code></pre> <p>Close the socket.</p> Source code in <code>academy/socket.py</code> <pre><code>def close(self, shutdown: bool = True) -&gt; None:\n    \"\"\"Close the socket.\"\"\"\n    if self.closed:\n        return\n    if shutdown:  # pragma: no branch\n        with contextlib.suppress(OSError):\n            # Some platforms may raise ENOTCONN here\n            self.socket.shutdown(socket.SHUT_RDWR)\n    self.socket.close()\n    self.closed = True\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.send","title":"send","text":"<pre><code>send(message: bytes) -&gt; None\n</code></pre> <p>Send bytes to the socket.</p> Note <p>This is a noop if the message is empty.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>bytes</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def send(self, message: bytes) -&gt; None:\n    \"\"\"Send bytes to the socket.\n\n    Note:\n        This is a noop if the message is empty.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    message_size = len(message)\n    if message_size == 0:\n        return\n    header = _make_header(message)\n    self._send_with_error_wrapping(header)\n\n    sent_size = 0\n    while sent_size &lt; message_size:\n        nbytes = min(message_size - sent_size, MESSAGE_CHUNK_SIZE)\n        chunk = message[sent_size : sent_size + nbytes]\n        self._send_with_error_wrapping(chunk)\n        sent_size += len(chunk)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.send_string","title":"send_string","text":"<pre><code>send_string(message: str) -&gt; None\n</code></pre> <p>Send a string to the socket.</p> <p>Strings are encoded with UTF-8.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def send_string(self, message: str) -&gt; None:\n    \"\"\"Send a string to the socket.\n\n    Strings are encoded with UTF-8.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    self.send(message.encode('utf-8'))\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.recv","title":"recv","text":"<pre><code>recv() -&gt; bytes | bytearray\n</code></pre> <p>Receive the next message from the socket.</p> <p>Returns:</p> <ul> <li> <code>bytes | bytearray</code>           \u2013            <p>Bytes containing the message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def recv(self) -&gt; bytes | bytearray:\n    \"\"\"Receive the next message from the socket.\n\n    Returns:\n        Bytes containing the message.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    header = _recv_from_socket(self.socket, MESSAGE_HEADER_SIZE)\n    message_size = _get_size_from_header(header)\n\n    buffer = bytearray(message_size)\n    received = 0\n    while received &lt; message_size:\n        nbytes = min(message_size - received, MESSAGE_CHUNK_SIZE)\n        chunk = _recv_from_socket(self.socket, nbytes)\n        # buffer.extend(chunk)\n        buffer[received : received + len(chunk)] = chunk\n        received += len(chunk)\n\n    return buffer\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.recv_string","title":"recv_string","text":"<pre><code>recv_string() -&gt; str\n</code></pre> <p>Receive the next message from the socket.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Message decoded as a UTF-8 string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def recv_string(self) -&gt; str:\n    \"\"\"Receive the next message from the socket.\n\n    Returns:\n        Message decoded as a UTF-8 string.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    return self.recv().decode('utf-8')\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer","title":"SimpleSocketServer","text":"<pre><code>SimpleSocketServer(\n    handler: Callable[[bytes], bytes | None],\n    *,\n    host: str = \"0.0.0.0\",\n    port: int | None = None,\n    timeout: float | None = 5\n)\n</code></pre> <p>Simple asyncio TCP socket server.</p> <p>Parameters:</p> <ul> <li> <code>handler</code>               (<code>Callable[[bytes], bytes | None]</code>)           \u2013            <p>Callback that handles a message and returns the response string. The handler is called synchronously within the client handler so it should not perform any heavy/blocking operations.</p> </li> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host to bind to.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Port to bind to. If <code>None</code>, a random port is bound to.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>5</code> )           \u2013            <p>Seconds to wait for the server to startup and shutdown.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def __init__(\n    self,\n    handler: Callable[[bytes], bytes | None],\n    *,\n    host: str = '0.0.0.0',\n    port: int | None = None,\n    timeout: float | None = 5,\n) -&gt; None:\n    self.host = host\n    self.port = port if port is not None else open_port()\n    self.handler = handler\n    self.timeout = timeout\n    self._started = threading.Event()\n    self._signal_stop: asyncio.Future[None] | None = None\n    self._loop: asyncio.AbstractEventLoop | None = None\n    self._thread: threading.Thread | None = None\n    self._lock = threading.Lock()\n    self._client_tasks: set[asyncio.Task[None]] = set()\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.serve_forever","title":"serve_forever  <code>async</code>","text":"<pre><code>serve_forever(stop: Future[None]) -&gt; None\n</code></pre> <p>Accept and handles connections forever.</p> <p>Parameters:</p> <ul> <li> <code>stop</code>               (<code>Future[None]</code>)           \u2013            <p>An asyncio future that this method blocks on. Can be used to signal externally that the coroutine should exit.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def serve_forever(self, stop: asyncio.Future[None]) -&gt; None:\n    \"\"\"Accept and handles connections forever.\n\n    Args:\n        stop: An asyncio future that this method blocks on. Can be used\n            to signal externally that the coroutine should exit.\n    \"\"\"\n    self._signal_stop = stop\n    server = await asyncio.start_server(\n        self._register_client_task,\n        host=self.host,\n        port=self.port,\n    )\n    logger.debug('TCP server listening at %s:%s', self.host, self.port)\n    self._started.set()\n\n    async with server:\n        await server.start_serving()\n        await self._signal_stop\n\n        for task in tuple(self._client_tasks):\n            task.cancel('Server has been closed.')\n            with contextlib.suppress(asyncio.CancelledError):\n                await task\n\n    if sys.version_info &gt;= (3, 13):  # pragma: &gt;=3.13 cover\n        server.close_clients()\n    self._started.clear()\n    logger.debug('TCP server finished at %s:%s', self.host, self.port)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.start_server_thread","title":"start_server_thread","text":"<pre><code>start_server_thread() -&gt; None\n</code></pre> <p>Start the server in a new thread.</p> Source code in <code>academy/socket.py</code> <pre><code>def start_server_thread(self) -&gt; None:\n    \"\"\"Start the server in a new thread.\"\"\"\n    with self._lock:\n        loop = asyncio.new_event_loop()\n        stop = loop.create_future()\n\n        def _target() -&gt; None:\n            asyncio.set_event_loop(loop)\n            loop.run_until_complete(self.serve_forever(stop))\n            loop.close()\n\n        self._loop = loop\n        self._thread = threading.Thread(\n            target=_target,\n            name='socket-server',\n        )\n        self._thread.start()\n        self._started.wait(self.timeout)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.stop_server_thread","title":"stop_server_thread","text":"<pre><code>stop_server_thread() -&gt; None\n</code></pre> <p>Stop the server thread.</p> Source code in <code>academy/socket.py</code> <pre><code>def stop_server_thread(self) -&gt; None:\n    \"\"\"Stop the server thread.\"\"\"\n    with self._lock:\n        if self._loop is None or self._thread is None:\n            return\n        assert self._signal_stop is not None\n        self._loop.call_soon_threadsafe(self._signal_stop.set_result, None)\n        self._thread.join(timeout=self.timeout)\n        if self._thread.is_alive():  # pragma: no cover\n            raise TimeoutError(\n                'Server thread did not gracefully exit '\n                f'within {self.timeout}s.',\n            )\n        self._loop = None\n        self._thread = None\n</code></pre>"},{"location":"api/socket/#academy.socket.address_by_hostname","title":"address_by_hostname","text":"<pre><code>address_by_hostname() -&gt; str\n</code></pre> <p>Get the IP address from the hostname of the local host.</p> Source code in <code>academy/socket.py</code> <pre><code>def address_by_hostname() -&gt; str:\n    \"\"\"Get the IP address from the hostname of the local host.\"\"\"\n    return socket.gethostbyname(platform.node())\n</code></pre>"},{"location":"api/socket/#academy.socket.address_by_interface","title":"address_by_interface","text":"<pre><code>address_by_interface(ifname: str) -&gt; str\n</code></pre> <p>Get the IP address of the given interface.</p> <p>Source: https://stackoverflow.com/questions/24196932/how-can-i-get-the-ip-address-of-eth0-in-python#24196955</p> <p>Parameters:</p> <ul> <li> <code>ifname</code>               (<code>str</code>)           \u2013            <p>Name of the interface whose address is to be returned.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def address_by_interface(ifname: str) -&gt; str:  # pragma: darwin no cover\n    \"\"\"Get the IP address of the given interface.\n\n    Source: https://stackoverflow.com/questions/24196932/how-can-i-get-the-ip-address-of-eth0-in-python#24196955\n\n    Args:\n        ifname: Name of the interface whose address is to be returned.\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    return socket.inet_ntoa(\n        fcntl.ioctl(\n            s.fileno(),\n            0x8915,  # SIOCGIFADDR\n            struct.pack('256s', bytes(ifname[:15], 'utf-8')),\n        )[20:24],\n    )\n</code></pre>"},{"location":"api/socket/#academy.socket.open_port","title":"open_port","text":"<pre><code>open_port() -&gt; int\n</code></pre> <p>Return open port.</p> <p>Source: https://stackoverflow.com/questions/2838244</p> Source code in <code>academy/socket.py</code> <pre><code>def open_port() -&gt; int:\n    \"\"\"Return open port.\n\n    Source: https://stackoverflow.com/questions/2838244\n    \"\"\"\n    while True:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind(('', 0))\n        s.listen(1)\n        port = s.getsockname()[1]\n        s.close()\n        if port not in _used_ports:  # pragma: no branch\n            _used_ports.add(port)\n            return port\n</code></pre>"},{"location":"api/socket/#academy.socket.wait_connection","title":"wait_connection","text":"<pre><code>wait_connection(\n    host: str,\n    port: int,\n    *,\n    sleep: float = 0.01,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a socket connection to be established.</p> <p>Repeatedly tries to open and close a socket connection to <code>host:port</code>. If successful, the function returns. If unsuccessful before the timeout, a <code>TimeoutError</code> is raised. The function will sleep for <code>sleep</code> seconds in between successive connection attempts.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host address to connect to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Host port to connect to.</p> </li> <li> <code>sleep</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Seconds to sleep after unsuccessful connections.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of seconds to wait for successful connections.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def wait_connection(\n    host: str,\n    port: int,\n    *,\n    sleep: float = 0.01,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a socket connection to be established.\n\n    Repeatedly tries to open and close a socket connection to `host:port`.\n    If successful, the function returns. If unsuccessful before the timeout,\n    a `TimeoutError` is raised. The function will sleep for `sleep` seconds\n    in between successive connection attempts.\n\n    Args:\n        host: Host address to connect to.\n        port: Host port to connect to.\n        sleep: Seconds to sleep after unsuccessful connections.\n        timeout: Maximum number of seconds to wait for successful connections.\n    \"\"\"\n    sleep = min(sleep, timeout) if timeout is not None else sleep\n    waited = 0.0\n\n    while True:\n        try:\n            start = time.perf_counter()\n            with socket.create_connection((host, port), timeout=timeout):\n                break\n        except OSError as e:\n            connection_time = time.perf_counter() - start\n            waited += connection_time\n            if timeout is not None and waited &gt;= timeout:\n                raise TimeoutError from e\n            time.sleep(sleep)\n            waited += sleep\n</code></pre>"},{"location":"api/state/","title":"academy.state","text":"<code>academy/state.py</code>"},{"location":"api/state/#academy.state.FileState","title":"FileState","text":"<pre><code>FileState(\n    filename: str | Path,\n    *,\n    flag: Literal[\"r\", \"w\", \"c\", \"n\"] = \"c\",\n    protocol: int | None = DEFAULT_PICKLE_PROTOCOL,\n    writeback: bool = False\n)\n</code></pre> <p>               Bases: <code>DbfilenameShelf[ValueT]</code></p> <p>Dictionary interface for persistent state.</p> <p>Persists arbitrary Python objects to disk using pickle and a dbm database.</p> Note <p>This class uses the shelve module so refer there for additional caveats.</p> Example <pre><code>from typing import Any\nfrom academy.behavior import Behavior, action\nfrom academy.state import FileState\n\nclass Example(Behavior):\n    def __init__(self) -&gt; None:\n        self.state_path = '/tmp/agent-state.dbm'\n\n    def on_setup(self) -&gt; None:\n        self.state: FileState[Any] = FileState(self.state_path)\n\n    def on_shutdown(self) -&gt; None:\n        self.state.close()\n\n    @action\n    def get_state(self, key: str) -&gt; Any:\n        return self.state[key]\n\n    @action\n    def modify_state(self, key: str, value: Any) -&gt; None:\n        self.state[key] = value\n</code></pre> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | Path</code>)           \u2013            <p>Base filename for the underlying databased used to store key-value pairs.</p> </li> <li> <code>flag</code>               (<code>Literal['r', 'w', 'c', 'n']</code>, default:                   <code>'c'</code> )           \u2013            <p>Open an existing database read-only: <code>r</code>; open an existing database for read and write: <code>w</code>; open a database for read and write, creating it if not existent: <code>c</code> (default); always create a new empty database for read and write: <code>n</code>.</p> </li> <li> <code>protocol</code>               (<code>int | None</code>, default:                   <code>DEFAULT_PICKLE_PROTOCOL</code> )           \u2013            <p>Pickling protocol. Defaults to version 5; <code>None</code> uses the pickle default version.</p> </li> <li> <code>writeback</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>By default (<code>False</code>), modified objects are only written when assigned. If <code>True</code>, the object will hold a cache of all entries accessed and write them back to the dict at sync and close times. This allows natural operations on mutable entries, but can consume much more memory and make sync and close take a long time.</p> </li> </ul> Source code in <code>academy/state.py</code> <pre><code>def __init__(\n    self,\n    filename: str | pathlib.Path,\n    *,\n    flag: Literal['r', 'w', 'c', 'n'] = 'c',\n    protocol: int | None = DEFAULT_PICKLE_PROTOCOL,\n    writeback: bool = False,\n) -&gt; None:\n    super().__init__(\n        str(filename),\n        flag=flag,\n        protocol=protocol,\n        writeback=writeback,\n    )\n</code></pre>"},{"location":"api/exchange/","title":"academy.exchange","text":"<code>academy/exchange/__init__.py</code>"},{"location":"api/exchange/#academy.exchange.Exchange","title":"Exchange","text":"<p>               Bases: <code>Protocol</code></p> <p>Message exchange client protocol.</p> <p>A message exchange hosts mailboxes for each entity (i.e., agent or client) in a multi-agent system. This protocol defines the client interface to an arbitrary exchange.</p> Warning <p>Exchange implementations should be efficiently pickleable so that agents and remote clients can establish client connections to the same exchange.</p>"},{"location":"api/exchange/#academy.exchange.Exchange.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange client.</p> Note <p>This does not alter the state of the exchange.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange client.\n\n    Note:\n        This does not alter the state of the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Behavior type of the agent.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Behavior type of the agent.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.register_client","title":"register_client","text":"<pre><code>register_client(*, name: str | None = None) -&gt; ClientId\n</code></pre> <p>Create a new client identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientId</code>           \u2013            <p>Unique identifier for the client's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def register_client(self, *, name: str | None = None) -&gt; ClientId:\n    \"\"\"Create a new client identifier and associated mailbox.\n\n    Args:\n        name: Optional human-readable name for the client.\n\n    Returns:\n        Unique identifier for the client's mailbox.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create a handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>aid</code> does not exist.</p> </li> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create a handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `aid` does not exist.\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.get_mailbox","title":"get_mailbox","text":"<pre><code>get_mailbox(uid: EntityId) -&gt; Mailbox\n</code></pre> <p>Get a client to a specific mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Mailbox</code>           \u2013            <p>Mailbox client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_mailbox(self, uid: EntityId) -&gt; Mailbox:\n    \"\"\"Get a client to a specific mailbox.\n\n    Args:\n        uid: EntityId of the mailbox.\n\n    Returns:\n        Mailbox client.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Exchange.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeMixin","title":"ExchangeMixin","text":"<p>Mixin class that adds basic methods to an exchange implementation.</p> <p>This adds a simple <code>repr</code>/<code>str</code>, context manager support, and the <code>register_agent</code>, <code>register_client</code>, and <code>get_handle</code> methods.</p>"},{"location":"api/exchange/#academy.exchange.ExchangeMixin.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self: Exchange,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n    return UnboundRemoteHandle(self, aid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Mailbox","title":"Mailbox","text":"<p>               Bases: <code>Protocol</code></p> <p>Client protocol that listens to incoming messages to a mailbox.</p>"},{"location":"api/exchange/#academy.exchange.Mailbox.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: Exchange\n</code></pre> <p>Exchange client.</p>"},{"location":"api/exchange/#academy.exchange.Mailbox.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>Mailbox address/identifier.</p>"},{"location":"api/exchange/#academy.exchange.Mailbox.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this mailbox client.</p> Warning <p>This does not close the mailbox in the exchange. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this mailbox client.\n\n    Warning:\n        This does not close the mailbox in the exchange. I.e., the exchange\n        will still accept new messages to this mailbox, but this client\n        will no longer be listening for them.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.Mailbox.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/http/","title":"academy.exchange.http","text":"<code>academy/exchange/http.py</code> <p>HTTP message exchange client and server.</p> <p>To start the exchange: <pre><code>python -m academy.exchange.http --host localhost --port 1234\n</code></pre></p> <p>Connect to the exchange through the client. <pre><code>from academy.exchange.http import HttpExchange\n\nwith HttpExchange('localhost', 1234) as exchange:\n    aid = exchange.register_agent()\n    mailbox = exchange.get_mailbox(aid)\n    ...\n    mailbox.close()\n</code></pre></p>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange","title":"HttpExchange","text":"<pre><code>HttpExchange(host: str, port: int)\n</code></pre> <p>               Bases: <code>ExchangeMixin</code></p> <p>Http exchange client.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host name of the exchange server.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port of the exchange server.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n) -&gt; None:\n    self.host = host\n    self.port = port\n\n    self._session = requests.Session()\n    self._mailbox_url = f'http://{self.host}:{self.port}/mailbox'\n    self._message_url = f'http://{self.host}:{self.port}/message'\n    self._discover_url = f'http://{self.host}:{self.port}/discover'\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this exchange client.</p> Source code in <code>academy/exchange/http.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this exchange client.\"\"\"\n    self._session.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    response = self._session.post(\n        self._mailbox_url,\n        json={\n            'mailbox': aid.model_dump_json(),\n            'behavior': ','.join(behavior.behavior_mro()),\n        },\n    )\n    response.raise_for_status()\n    logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.register_client","title":"register_client","text":"<pre><code>register_client(*, name: str | None = None) -&gt; ClientId\n</code></pre> <p>Create a new client identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientId</code>           \u2013            <p>Unique identifier for the client's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def register_client(\n    self,\n    *,\n    name: str | None = None,\n) -&gt; ClientId:\n    \"\"\"Create a new client identifier and associated mailbox.\n\n    Args:\n        name: Optional human-readable name for the client.\n\n    Returns:\n        Unique identifier for the client's mailbox.\n    \"\"\"\n    cid = ClientId.new(name=name)\n    response = self._session.post(\n        self._mailbox_url,\n        json={'mailbox': cid.model_dump_json()},\n    )\n    response.raise_for_status()\n    logger.debug('Registered %s in %s', cid, self)\n    return cid\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exists.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exists.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    response = self._session.delete(\n        self._mailbox_url,\n        json={'mailbox': uid.model_dump_json()},\n    )\n    response.raise_for_status()\n    logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> Warning <p>Discoverability is not implemented on the HTTP exchange.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Warning:\n        Discoverability is not implemented on the HTTP exchange.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    behavior_str = f'{behavior.__module__}.{behavior.__name__}'\n    response = self._session.get(\n        self._discover_url,\n        json={\n            'behavior': behavior_str,\n            'allow_subclasses': allow_subclasses,\n        },\n    )\n    response.raise_for_status()\n    agent_ids = [\n        aid\n        for aid in response.json()['agent_ids'].split(',')\n        if len(aid) &gt; 0\n    ]\n    return tuple(AgentId(uid=uuid.UUID(aid)) for aid in agent_ids)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.get_mailbox","title":"get_mailbox","text":"<pre><code>get_mailbox(uid: EntityId) -&gt; HttpMailbox\n</code></pre> <p>Get a client to a specific mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HttpMailbox</code>           \u2013            <p>Mailbox client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def get_mailbox(self, uid: EntityId) -&gt; HttpMailbox:\n    \"\"\"Get a client to a specific mailbox.\n\n    Args:\n        uid: EntityId of the mailbox.\n\n    Returns:\n        Mailbox client.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n    \"\"\"\n    return HttpMailbox(uid, self)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    response = self._session.put(\n        self._message_url,\n        json={'message': message.model_dump_json()},\n    )\n    if response.status_code == _NOT_FOUND_CODE:\n        raise BadEntityIdError(uid)\n    elif response.status_code == _FORBIDDEN_CODE:\n        raise MailboxClosedError(uid)\n    response.raise_for_status()\n    logger.debug('Sent %s to %s', type(message).__name__, uid)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpExchange.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self: Exchange,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n    return UnboundRemoteHandle(self, aid)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpMailbox","title":"HttpMailbox","text":"<pre><code>HttpMailbox(uid: EntityId, exchange: HttpExchange)\n</code></pre> <p>Client interface to a mailbox hosted in an HTTP exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> <li> <code>exchange</code>               (<code>HttpExchange</code>)           \u2013            <p>Exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox with <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def __init__(\n    self,\n    uid: EntityId,\n    exchange: HttpExchange,\n) -&gt; None:\n    self._uid = uid\n    self._exchange = exchange\n\n    response = self.exchange._session.get(\n        self.exchange._mailbox_url,\n        json={'mailbox': uid.model_dump_json()},\n    )\n    response.raise_for_status()\n    data = response.json()\n    if not data['exists']:\n        raise BadEntityIdError(uid)\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpMailbox.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: HttpExchange\n</code></pre> <p>Exchange client.</p>"},{"location":"api/exchange/http/#academy.exchange.http.HttpMailbox.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>Mailbox address/identifier.</p>"},{"location":"api/exchange/http/#academy.exchange.http.HttpMailbox.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this mailbox client.</p> Warning <p>This does not close the mailbox in the exchange. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/http.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this mailbox client.\n\n    Warning:\n        This does not close the mailbox in the exchange. I.e., the exchange\n        will still accept new messages to this mailbox, but this client\n        will no longer be listening for them.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.HttpMailbox.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    try:\n        response = self.exchange._session.get(\n            self.exchange._message_url,\n            json={'mailbox': self.mailbox_id.model_dump_json()},\n            timeout=timeout,\n        )\n    except requests.exceptions.Timeout as e:\n        raise TimeoutError(\n            f'Failed to receive response in {timeout} seconds.',\n        ) from e\n    if response.status_code == _FORBIDDEN_CODE:\n        raise MailboxClosedError(self.mailbox_id)\n    response.raise_for_status()\n\n    message = BaseMessage.model_from_json(response.json().get('message'))\n    logger.debug(\n        'Received %s to %s',\n        type(response).__name__,\n        self.mailbox_id,\n    )\n    return message\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.create_app","title":"create_app","text":"<pre><code>create_app() -&gt; Application\n</code></pre> <p>Create a new server application.</p> Source code in <code>academy/exchange/http.py</code> <pre><code>def create_app() -&gt; Application:\n    \"\"\"Create a new server application.\"\"\"\n    manager = _MailboxManager()\n    app = Application()\n    app[MANAGER_KEY] = manager\n\n    app.router.add_post('/mailbox', _create_mailbox_route)\n    app.router.add_delete('/mailbox', _terminate_route)\n    app.router.add_get('/mailbox', _check_mailbox_route)\n    app.router.add_put('/message', _send_message_route)\n    app.router.add_get('/message', _recv_message_route)\n    app.router.add_get('/discover', _discover_route)\n\n    return app\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.serve_app","title":"serve_app  <code>async</code>","text":"<pre><code>serve_app(\n    app: Application, host: str, port: int\n) -&gt; AsyncGenerator[None]\n</code></pre> <p>Serve an application as a context manager.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>Application</code>)           \u2013            <p>Application to run.</p> </li> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host to bind to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port to bind to.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def serve_app(\n    app: Application,\n    host: str,\n    port: int,\n) -&gt; AsyncGenerator[None]:\n    \"\"\"Serve an application as a context manager.\n\n    Args:\n        app: Application to run.\n        host: Host to bind to.\n        port: Port to bind to.\n    \"\"\"\n    runner = AppRunner(app)\n    try:\n        await runner.setup()\n        site = TCPSite(runner, host, port)\n        await site.start()\n        logger.info('Exchange listening on %s:%s (ctrl-C to exit)', host, port)\n        yield\n    finally:\n        await runner.cleanup()\n        logger.info('Exchange closed!')\n</code></pre>"},{"location":"api/exchange/http/#academy.exchange.http.spawn_http_exchange","title":"spawn_http_exchange","text":"<pre><code>spawn_http_exchange(\n    host: str = \"0.0.0.0\",\n    port: int = 5463,\n    *,\n    level: int | str = WARNING,\n    timeout: float | None = None\n) -&gt; Generator[HttpExchange]\n</code></pre> <p>Context manager that spawns an HTTP exchange in a subprocess.</p> <p>This function spawns a new process (rather than forking) and wait to return until a connection with the exchange has been established. When exiting the context manager, <code>SIGINT</code> will be sent to the exchange process. If the process does not exit within 5 seconds, it will be killed.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host the exchange should listen on.</p> </li> <li> <code>port</code>               (<code>int</code>, default:                   <code>5463</code> )           \u2013            <p>Port the exchange should listen on.</p> </li> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>WARNING</code> )           \u2013            <p>Logging level.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection timeout when waiting for exchange to start.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[HttpExchange]</code>           \u2013            <p>Exchange interface connected to the spawned exchange.</p> </li> </ul> Source code in <code>academy/exchange/http.py</code> <pre><code>@contextlib.contextmanager\ndef spawn_http_exchange(\n    host: str = '0.0.0.0',\n    port: int = 5463,\n    *,\n    level: int | str = logging.WARNING,\n    timeout: float | None = None,\n) -&gt; Generator[HttpExchange]:\n    \"\"\"Context manager that spawns an HTTP exchange in a subprocess.\n\n    This function spawns a new process (rather than forking) and wait to\n    return until a connection with the exchange has been established.\n    When exiting the context manager, `SIGINT` will be sent to the exchange\n    process. If the process does not exit within 5 seconds, it will be\n    killed.\n\n    Args:\n        host: Host the exchange should listen on.\n        port: Port the exchange should listen on.\n        level: Logging level.\n        timeout: Connection timeout when waiting for exchange to start.\n\n    Returns:\n        Exchange interface connected to the spawned exchange.\n    \"\"\"\n    # Fork is not safe in multi-threaded context.\n    multiprocessing.set_start_method('spawn')\n\n    exchange_process = multiprocessing.Process(\n        target=_run,\n        args=(host, port),\n        kwargs={'level': level},\n    )\n    exchange_process.start()\n\n    logger.info('Starting exchange server...')\n    wait_connection(host, port, timeout=timeout)\n    logger.info('Started exchange server!')\n\n    try:\n        with HttpExchange(host, port) as exchange:\n            yield exchange\n    finally:\n        logger.info('Terminating exchange server...')\n        wait = 5\n        exchange_process.terminate()\n        exchange_process.join(timeout=wait)\n        if exchange_process.exitcode is None:  # pragma: no cover\n            logger.info(\n                'Killing exchange server after waiting %s seconds',\n                wait,\n            )\n            exchange_process.kill()\n        else:\n            logger.info('Terminated exchange server!')\n        exchange_process.close()\n</code></pre>"},{"location":"api/exchange/hybrid/","title":"academy.exchange.hybrid","text":"<code>academy/exchange/hybrid.py</code>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange","title":"HybridExchange","text":"<pre><code>HybridExchange(\n    redis_host: str,\n    redis_port: int,\n    *,\n    interface: str | None = None,\n    namespace: str | None = \"default\",\n    redis_kwargs: dict[str, Any] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeMixin</code></p> <p>Hybrid exchange.</p> <p>The hybrid exchange uses peer-to-peer communication via TCP and a central Redis server for mailbox state and queueing messages for offline entities.</p> <p>Parameters:</p> <ul> <li> <code>redis_host</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>redis_port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>namespace</code>               (<code>str | None</code>, default:                   <code>'default'</code> )           \u2013            <p>Redis key namespace. If <code>None</code> a random key prefix is generated.</p> </li> <li> <code>redis_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(\n    self,\n    redis_host: str,\n    redis_port: int,\n    *,\n    interface: str | None = None,\n    namespace: str | None = 'default',\n    redis_kwargs: dict[str, Any] | None = None,\n) -&gt; None:\n    self._namespace = (\n        namespace\n        if namespace is not None\n        else uuid_to_base32(uuid.uuid4())\n    )\n    self._interface = interface\n    self._redis_host = redis_host\n    self._redis_port = redis_port\n    self._redis_kwargs = redis_kwargs if redis_kwargs is not None else {}\n\n    self._init_connections()\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange interface.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange interface.\"\"\"\n    self._redis_client.close()\n    self._socket_pool.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    self._redis_client.set(\n        self._status_key(aid),\n        _MailboxState.ACTIVE.value,\n    )\n    self._redis_client.set(\n        self._behavior_key(aid),\n        ','.join(behavior.behavior_mro()),\n    )\n    logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.register_client","title":"register_client","text":"<pre><code>register_client(*, name: str | None = None) -&gt; ClientId\n</code></pre> <p>Create a new client identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientId</code>           \u2013            <p>Unique identifier for the client's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def register_client(\n    self,\n    *,\n    name: str | None = None,\n) -&gt; ClientId:\n    \"\"\"Create a new client identifier and associated mailbox.\n\n    Args:\n        name: Optional human-readable name for the client.\n\n    Returns:\n        Unique identifier for the client's mailbox.\n    \"\"\"\n    cid = ClientId.new(name=name)\n    self._redis_client.set(\n        self._status_key(cid),\n        _MailboxState.ACTIVE.value,\n    )\n    logger.debug('Registered %s in %s', cid, self)\n    return cid\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> <p>This sets the state of the mailbox to inactive in the Redis server, and deletes any queued messages in Redis.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    This sets the state of the mailbox to inactive in the Redis server,\n    and deletes any queued messages in Redis.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    self._redis_client.set(\n        self._status_key(uid),\n        _MailboxState.INACTIVE.value,\n    )\n    # Sending a close sentinel to the queue is a quick way to force\n    # the entity waiting on messages to the mailbox to stop blocking.\n    # This assumes that only one entity is reading from the mailbox.\n    self._redis_client.rpush(self._queue_key(uid), _CLOSE_SENTINEL)\n    if isinstance(uid, AgentId):\n        self._redis_client.delete(self._behavior_key(uid))\n    logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> Warning <p>This method is O(n) and scans all keys in the Redis server.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Warning:\n        This method is O(n) and scans all keys in the Redis server.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    fqp = f'{behavior.__module__}.{behavior.__name__}'\n    for key in self._redis_client.scan_iter(\n        f'{self._namespace}:behavior:*',\n    ):\n        mro_str = self._redis_client.get(key)\n        assert isinstance(mro_str, str)\n        mro = mro_str.split(',')\n        if fqp == mro[0] or (allow_subclasses and fqp in mro):\n            aid: AgentId[Any] = AgentId(\n                uid=base32_to_uuid(key.split(':')[-1]),\n            )\n            found.append(aid)\n    active: list[AgentId[Any]] = []\n    for aid in found:\n        status = self._redis_client.get(self._status_key(aid))\n        if status == _MailboxState.ACTIVE.value:  # pragma: no branch\n            active.append(aid)\n    return tuple(active)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.get_mailbox","title":"get_mailbox","text":"<pre><code>get_mailbox(uid: EntityId) -&gt; HybridMailbox\n</code></pre> <p>Get a client to a specific mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HybridMailbox</code>           \u2013            <p>Mailbox client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def get_mailbox(self, uid: EntityId) -&gt; HybridMailbox:\n    \"\"\"Get a client to a specific mailbox.\n\n    Args:\n        uid: EntityId of the mailbox.\n\n    Returns:\n        Mailbox client.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n    \"\"\"\n    status = self._redis_client.get(self._status_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    return HybridMailbox(uid, self, interface=self._interface)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>To send a message, the client first checks that the state of the mailbox in Redis is active; otherwise, an error is raised. Then, the client checks to see if the peer entity is available by checking for an address of the peer in Redis. If the peer's address is found, the message is sent directly to the peer via ZMQ; otherwise, the message is put in a Redis queue for later retrieval.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    To send a message, the client first checks that the state of the\n    mailbox in Redis is active; otherwise, an error is raised. Then,\n    the client checks to see if the peer entity is available by\n    checking for an address of the peer in Redis. If the peer's address\n    is found, the message is sent directly to the peer via ZMQ; otherwise,\n    the message is put in a Redis queue for later retrieval.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    address = self._address_cache.get(uid, None)\n    if address is not None:\n        try:\n            # This is as optimistic as possible. If the address of the\n            # peer is cached, we assume the mailbox is still active and\n            # the peer is still listening.\n            self._send_direct(address, message)\n        except (SocketClosedError, OSError):\n            # Our optimism let us down so clear the cache and try the\n            # standard flow.\n            self._address_cache.pop(uid)\n        else:\n            return\n\n    status = self._redis_client.get(self._status_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status == _MailboxState.INACTIVE.value:\n        raise MailboxClosedError(uid)\n\n    maybe_address = self._redis_client.get(self._address_key(uid))\n    try:\n        # This branching is a little odd. We want to fall back to\n        # Redis for message sending on two conditions: direct send fails\n        # or no address was found. We raise a TypeError if no address\n        # was found as a shortcut to get to the fall back.\n        if isinstance(maybe_address, (bytes, str)):\n            decoded_address = (\n                maybe_address.decode('utf-8')\n                if isinstance(maybe_address, bytes)\n                else maybe_address\n            )\n            self._send_direct(decoded_address, message)\n            self._address_cache[uid] = decoded_address\n        else:\n            raise TypeError('Did not active peer address in Redis.')\n    except (TypeError, SocketClosedError, OSError):\n        self._redis_client.rpush(\n            self._queue_key(uid),\n            message.model_serialize(),\n        )\n        logger.debug(\n            'Sent %s to %s via redis',\n            type(message).__name__,\n            uid,\n        )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchange.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self: Exchange,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n    return UnboundRemoteHandle(self, aid)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridMailbox","title":"HybridMailbox","text":"<pre><code>HybridMailbox(\n    uid: EntityId,\n    exchange: HybridExchange,\n    *,\n    interface: str | None = None,\n    port: int | None = None\n)\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Client protocol that listens to incoming messages to a mailbox.</p> <p>This class acts as the endpoint for messages sent to a particular mailbox. This is done via starting two threads once initialized: (1) a ZMQ server thread that listens for messages from peers, and (2) a thread that checks the Redis server for any offline messages and state changes to the mailbox (i.e., mailbox closure).</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> <li> <code>exchange</code>               (<code>HybridExchange</code>)           \u2013            <p>Exchange client.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Port to use for peer-to-peer communication. Randomly selected if <code>None</code>.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(\n    self,\n    uid: EntityId,\n    exchange: HybridExchange,\n    *,\n    interface: str | None = None,\n    port: int | None = None,\n) -&gt; None:\n    self._uid = uid\n    self._exchange = exchange\n    self._interface = interface\n    self._messages: Queue[Message] = Queue()\n\n    self._closed = threading.Event()\n    self._socket_poll_timeout_ms = _SOCKET_POLL_TIMEOUT_MS\n\n    host = (\n        address_by_interface(interface)\n        if interface is not None\n        else address_by_hostname()\n    )\n    self._server = SimpleSocketServer(\n        handler=self._server_handler,\n        host=host,\n        port=port,\n        timeout=_THREAD_JOIN_TIMEOUT,\n    )\n    self._server.start_server_thread()\n\n    self.exchange._redis_client.set(\n        self.exchange._address_key(uid),\n        f'{self._server.host}:{self._server.port}',\n    )\n\n    self._redis_thread = threading.Thread(\n        target=self._redis_watcher,\n        name=f'hybrid-mailbox-redis-watcher-{uid}',\n    )\n    self._redis_started = threading.Event()\n    self._redis_thread.start()\n    self._redis_started.wait(timeout=_THREAD_START_TIMEOUT)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridMailbox.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: HybridExchange\n</code></pre> <p>Exchange client.</p>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridMailbox.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>Mailbox address/identifier.</p>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridMailbox.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this mailbox client.</p> Warning <p>This does not close the mailbox in the exchange. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this mailbox client.\n\n    Warning:\n        This does not close the mailbox in the exchange. I.e., the exchange\n        will still accept new messages to this mailbox, but this client\n        will no longer be listening for them.\n    \"\"\"\n    self._closed.set()\n    self.exchange._redis_client.delete(\n        self.exchange._address_key(self.mailbox_id),\n    )\n\n    self._server.stop_server_thread()\n\n    self._redis_thread.join(_THREAD_JOIN_TIMEOUT)\n    if self._redis_thread.is_alive():  # pragma: no cover\n        raise TimeoutError(\n            'Redis watcher thread failed to exit within '\n            f'{_THREAD_JOIN_TIMEOUT} seconds.',\n        )\n\n    self._messages.close()\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridMailbox.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed. Note that this will be cast to an int which is required by the Redis API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed. Note that this will\n            be cast to an int which is required by the Redis API.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    try:\n        return self._messages.get(timeout=timeout)\n    except QueueClosedError:\n        raise MailboxClosedError(self.mailbox_id) from None\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.base32_to_uuid","title":"base32_to_uuid","text":"<pre><code>base32_to_uuid(uid: str) -&gt; UUID\n</code></pre> <p>Parse a base32 string as a UUID.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def base32_to_uuid(uid: str) -&gt; uuid.UUID:\n    \"\"\"Parse a base32 string as a UUID.\"\"\"\n    padding = '=' * ((8 - len(uid) % 8) % 8)\n    padded = uid + padding\n    uid_bytes = base64.b32decode(padded)\n    return uuid.UUID(bytes=uid_bytes)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.uuid_to_base32","title":"uuid_to_base32","text":"<pre><code>uuid_to_base32(uid: UUID) -&gt; str\n</code></pre> <p>Encode a UUID as a trimmed base32 string.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def uuid_to_base32(uid: uuid.UUID) -&gt; str:\n    \"\"\"Encode a UUID as a trimmed base32 string.\"\"\"\n    uid_bytes = uid.bytes\n    base32_bytes = base64.b32encode(uid_bytes).rstrip(b'=')\n    return base32_bytes.decode('utf-8')\n</code></pre>"},{"location":"api/exchange/proxystore/","title":"academy.exchange.proxystore","text":"<code>academy/exchange/proxystore.py</code>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange","title":"ProxyStoreExchange","text":"<pre><code>ProxyStoreExchange(\n    exchange: Exchange,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeMixin</code></p> <p>Wrap an Exchange with ProxyStore support.</p> <p>Sending large action payloads via the exchange can result in considerable slowdowns. This Exchange wrapper can replace arguments in action requests and results in action responses with proxies to reduce communication costs.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Exchange to wrap.</p> </li> <li> <code>store</code>               (<code>Store[Any]</code>)           \u2013            <p>Store to use for proxying data.</p> </li> <li> <code>should_proxy</code>               (<code>Callable[[Any], bool]</code>)           \u2013            <p>A callable that returns <code>True</code> if an object should be proxied. This is applied to every positional and keyword argument and result value.</p> </li> <li> <code>resolve_async</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Resolve proxies asynchronously when received.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    exchange: Exchange,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    self.exchange = exchange\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n    register_store(store, exist_ok=True)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange client.</p> Note <p>This does not alter the state of the exchange.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange client.\n\n    Note:\n        This does not alter the state of the exchange.\n    \"\"\"\n    self.exchange.close()\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    return self.exchange.register_agent(\n        behavior,\n        agent_id=agent_id,\n        name=name,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.register_client","title":"register_client","text":"<pre><code>register_client(*, name: str | None = None) -&gt; ClientId\n</code></pre> <p>Create a new client identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientId</code>           \u2013            <p>Unique identifier for the client's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def register_client(\n    self,\n    *,\n    name: str | None = None,\n) -&gt; ClientId:\n    \"\"\"Create a new client identifier and associated mailbox.\n\n    Args:\n        name: Optional human-readable name for the client.\n\n    Returns:\n        Unique identifier for the client's mailbox.\n    \"\"\"\n    return self.exchange.register_client(name=name)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    self.exchange.terminate(uid)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    return self.exchange.discover(\n        behavior,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.get_mailbox","title":"get_mailbox","text":"<pre><code>get_mailbox(uid: EntityId) -&gt; Mailbox\n</code></pre> <p>Get a client to a specific mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Mailbox</code>           \u2013            <p>Mailbox client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def get_mailbox(self, uid: EntityId) -&gt; Mailbox:\n    \"\"\"Get a client to a specific mailbox.\n\n    Args:\n        uid: EntityId of the mailbox.\n\n    Returns:\n        Mailbox client.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n    \"\"\"\n    base_mailbox = self.exchange.get_mailbox(uid)\n    return ProxyStoreMailbox(base_mailbox, self, self.resolve_async)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    if isinstance(message, ActionRequest):\n        message.pargs = _proxy_iterable(\n            message.pargs,\n            self.store,\n            self.should_proxy,\n        )\n        message.kargs = _proxy_mapping(\n            message.kargs,\n            self.store,\n            self.should_proxy,\n        )\n    if isinstance(message, ActionResponse) and message.result is not None:\n        message.result = _proxy_item(\n            message.result,\n            self.store,\n            self.should_proxy,\n        )\n\n    self.exchange.send(uid, message)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchange.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self: Exchange,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n    return UnboundRemoteHandle(self, aid)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreMailbox","title":"ProxyStoreMailbox","text":"<pre><code>ProxyStoreMailbox(\n    mailbox: Mailbox,\n    exchange: ProxyStoreExchange,\n    resolve_async: bool = False,\n)\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Client protocol that listens to incoming messages to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>mailbox</code>               (<code>Mailbox</code>)           \u2013            <p>The mailbox created by the wrapped exchange.</p> </li> <li> <code>exchange</code>               (<code>ProxyStoreExchange</code>)           \u2013            <p>The wrapper exchange.</p> </li> <li> <code>resolve_async</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Begin resolving proxies in action requests or responses asynchronously once the message is received.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    mailbox: Mailbox,\n    exchange: ProxyStoreExchange,\n    resolve_async: bool = False,\n) -&gt; None:\n    self._exchange = exchange\n    self._mailbox = mailbox\n    self._resolve_async = resolve_async\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreMailbox.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: Exchange\n</code></pre> <p>Exchange client.</p>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreMailbox.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>Mailbox address/identifier.</p>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreMailbox.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this mailbox client.</p> Warning <p>This does not close the mailbox in the exchange. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this mailbox client.\n\n    Warning:\n        This does not close the mailbox in the exchange. I.e., the exchange\n        will still accept new messages to this mailbox, but this client\n        will no longer be listening for them.\n    \"\"\"\n    self._mailbox.close()\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreMailbox.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    message = self._mailbox.recv(timeout)\n    if self._resolve_async and isinstance(message, ActionRequest):\n        for arg in (*message.pargs, *message.kargs.values()):\n            if type(arg) is Proxy:\n                resolve_async(arg)\n    elif (\n        self._resolve_async\n        and isinstance(message, ActionResponse)\n        and type(message.result) is Proxy\n    ):\n        resolve_async(message.result)\n    return message\n</code></pre>"},{"location":"api/exchange/queue/","title":"academy.exchange.queue","text":"<code>academy/exchange/queue.py</code>"},{"location":"api/exchange/queue/#academy.exchange.queue.QueueClosedError","title":"QueueClosedError","text":"<p>               Bases: <code>Exception</code></p> <p>Queue has been closed exception.</p>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue","title":"AsyncQueue","text":"<pre><code>AsyncQueue()\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Simple async queue.</p> <p>This is a simple backport of Python 3.13 queues which have a shutdown method and exception type.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._queue: asyncio.PriorityQueue[_Item[T]] = asyncio.PriorityQueue()\n    self._closed = False\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.close","title":"close  <code>async</code>","text":"<pre><code>close(immediate: bool = False) -&gt; None\n</code></pre> <p>Close the queue.</p> <p>This will cause <code>get</code> and <code>put</code> to raise <code>QueueClosedError</code>.</p> <p>Parameters:</p> <ul> <li> <code>immediate</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Close the queue immediately, rather than once the queue is empty.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>async def close(self, immediate: bool = False) -&gt; None:\n    \"\"\"Close the queue.\n\n    This will cause `get` and `put` to raise `QueueClosedError`.\n\n    Args:\n        immediate: Close the queue immediately, rather than once the\n            queue is empty.\n    \"\"\"\n    if not self.closed():\n        self._closed = True\n        priority = CLOSE_PRIORITY if immediate else DEFAULT_PRIORITY\n        await self._queue.put(_Item(priority, CLOSE_SENTINEL))\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.closed","title":"closed","text":"<pre><code>closed() -&gt; bool\n</code></pre> <p>Check if the queue has been closed.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def closed(self) -&gt; bool:\n    \"\"\"Check if the queue has been closed.\"\"\"\n    return self._closed\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.get","title":"get  <code>async</code>","text":"<pre><code>get() -&gt; T\n</code></pre> <p>Remove and return the next item from the queue (blocking).</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>async def get(self) -&gt; T:\n    \"\"\"Remove and return the next item from the queue (blocking).\"\"\"\n    item = await self._queue.get()\n    if item.value is CLOSE_SENTINEL:\n        raise QueueClosedError\n    return cast(T, item.value)\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.put","title":"put  <code>async</code>","text":"<pre><code>put(item: T) -&gt; None\n</code></pre> <p>Put an item on the queue.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>async def put(self, item: T) -&gt; None:\n    \"\"\"Put an item on the queue.\"\"\"\n    if self.closed():\n        raise QueueClosedError\n    await self._queue.put(_Item(DEFAULT_PRIORITY, item))\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue","title":"Queue","text":"<pre><code>Queue()\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Simple queue.</p> <p>This is a simple backport of Python 3.13 queues which have a shutdown method and exception type.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._queue: queue.PriorityQueue[_Item[T]] = queue.PriorityQueue()\n    self._closed = False\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.close","title":"close","text":"<pre><code>close(immediate: bool = False) -&gt; None\n</code></pre> <p>Close the queue.</p> <p>This will cause <code>get</code> and <code>put</code> to raise <code>QueueClosedError</code>.</p> <p>Parameters:</p> <ul> <li> <code>immediate</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Close the queue immediately, rather than once the queue is empty.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>def close(self, immediate: bool = False) -&gt; None:\n    \"\"\"Close the queue.\n\n    This will cause `get` and `put` to raise `QueueClosedError`.\n\n    Args:\n        immediate: Close the queue immediately, rather than once the\n            queue is empty.\n    \"\"\"\n    if not self.closed():\n        self._closed = True\n        priority = CLOSE_PRIORITY if immediate else DEFAULT_PRIORITY\n        self._queue.put(_Item(priority, CLOSE_SENTINEL))\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.closed","title":"closed","text":"<pre><code>closed() -&gt; bool\n</code></pre> <p>Check if the queue has been closed.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def closed(self) -&gt; bool:\n    \"\"\"Check if the queue has been closed.\"\"\"\n    return self._closed\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.get","title":"get","text":"<pre><code>get(timeout: float | None = None) -&gt; T\n</code></pre> <p>Remove and return the next item from the queue (blocking).</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Block at most <code>timeout</code> seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>if no item was available within <code>timeout</code> seconds.</p> </li> <li> <code>QueueClosedError</code>             \u2013            <p>if the queue was closed.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>def get(self, timeout: float | None = None) -&gt; T:\n    \"\"\"Remove and return the next item from the queue (blocking).\n\n    Args:\n        timeout: Block at most `timeout` seconds.\n\n    Raises:\n        TimeoutError: if no item was available within `timeout` seconds.\n        QueueClosedError: if the queue was closed.\n    \"\"\"\n    try:\n        item = self._queue.get(timeout=timeout)\n    except queue.Empty:\n        raise TimeoutError from None\n    if item.value is CLOSE_SENTINEL:\n        # Push the sentinel back to the queue in case another thread\n        # has called get.\n        self._queue.put(_Item(CLOSE_PRIORITY, CLOSE_SENTINEL))\n        raise QueueClosedError\n    return cast(T, item.value)\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.put","title":"put","text":"<pre><code>put(item: T) -&gt; None\n</code></pre> <p>Put an item on the queue.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>T</code>)           \u2013            <p>The item to put on the queue.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>QueueClosedError</code>             \u2013            <p>if the queue was closed.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>def put(self, item: T) -&gt; None:\n    \"\"\"Put an item on the queue.\n\n    Args:\n        item: The item to put on the queue.\n\n    Raises:\n        QueueClosedError: if the queue was closed.\n    \"\"\"\n    if self.closed():\n        raise QueueClosedError\n    self._queue.put(_Item(DEFAULT_PRIORITY, item))\n</code></pre>"},{"location":"api/exchange/redis/","title":"academy.exchange.redis","text":"<code>academy/exchange/redis.py</code>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange","title":"RedisExchange","text":"<pre><code>RedisExchange(\n    hostname: str,\n    port: int,\n    *,\n    timeout: int | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>               Bases: <code>ExchangeMixin</code></p> <p>Redis-hosted message exchange interface.</p> <p>Parameters:</p> <ul> <li> <code>hostname</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> <li> <code>timeout</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout for waiting on the next message. If <code>None</code>, the timeout will be set to one second but will loop indefinitely.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    hostname: str,\n    port: int,\n    *,\n    timeout: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    self.hostname = hostname\n    self.port = port\n    self.timeout = timeout\n    self._kwargs = kwargs\n    self._client = redis.Redis(\n        host=hostname,\n        port=port,\n        decode_responses=False,\n        **kwargs,\n    )\n    self._client.ping()\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange interface.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange interface.\"\"\"\n    self._client.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    self._client.set(self._active_key(aid), _MailboxState.ACTIVE.value)\n    self._client.set(\n        self._behavior_key(aid),\n        ','.join(behavior.behavior_mro()),\n    )\n    logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.register_client","title":"register_client","text":"<pre><code>register_client(*, name: str | None = None) -&gt; ClientId\n</code></pre> <p>Create a new client identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientId</code>           \u2013            <p>Unique identifier for the client's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def register_client(\n    self,\n    *,\n    name: str | None = None,\n) -&gt; ClientId:\n    \"\"\"Create a new client identifier and associated mailbox.\n\n    Args:\n        name: Optional human-readable name for the client.\n\n    Returns:\n        Unique identifier for the client's mailbox.\n    \"\"\"\n    cid = ClientId.new(name=name)\n    self._client.set(self._active_key(cid), _MailboxState.ACTIVE.value)\n    logger.debug('Registered %s in %s', cid, self)\n    return cid\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    self._client.set(self._active_key(uid), _MailboxState.INACTIVE.value)\n    # Sending a close sentinel to the queue is a quick way to force\n    # the entity waiting on messages to the mailbox to stop blocking.\n    # This assumes that only one entity is reading from the mailbox.\n    self._client.rpush(self._queue_key(uid), _CLOSE_SENTINEL)\n    if isinstance(uid, AgentId):\n        self._client.delete(self._behavior_key(uid))\n    logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior], allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> Warning <p>This method is O(n) and scans all keys in the Redis server.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Warning:\n        This method is O(n) and scans all keys in the Redis server.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    fqp = f'{behavior.__module__}.{behavior.__name__}'\n    for key in self._client.scan_iter('behavior:*'):\n        mro_str = self._client.get(key)\n        assert isinstance(mro_str, str)\n        mro = mro_str.split(',')\n        if fqp == mro[0] or (allow_subclasses and fqp in mro):\n            aid: AgentId[Any] = AgentId(uid=uuid.UUID(key.split(':')[-1]))\n            found.append(aid)\n    active: list[AgentId[Any]] = []\n    for aid in found:\n        status = self._client.get(self._active_key(aid))\n        if status == _MailboxState.ACTIVE.value:  # pragma: no branch\n            active.append(aid)\n    return tuple(active)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.get_mailbox","title":"get_mailbox","text":"<pre><code>get_mailbox(uid: EntityId) -&gt; RedisMailbox\n</code></pre> <p>Get a client to a specific mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RedisMailbox</code>           \u2013            <p>Mailbox client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def get_mailbox(self, uid: EntityId) -&gt; RedisMailbox:\n    \"\"\"Get a client to a specific mailbox.\n\n    Args:\n        uid: EntityId of the mailbox.\n\n    Returns:\n        Mailbox client.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n    \"\"\"\n    return RedisMailbox(uid, self)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    status = self._client.get(self._active_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status == _MailboxState.INACTIVE.value:\n        raise MailboxClosedError(uid)\n    else:\n        self._client.rpush(self._queue_key(uid), message.model_serialize())\n        logger.debug('Sent %s to %s', type(message).__name__, uid)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchange.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self: Exchange,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n    return UnboundRemoteHandle(self, aid)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisMailbox","title":"RedisMailbox","text":"<pre><code>RedisMailbox(uid: EntityId, exchange: RedisExchange)\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Client protocol that listens to incoming messages to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> <li> <code>exchange</code>               (<code>RedisExchange</code>)           \u2013            <p>Exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox with <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(self, uid: EntityId, exchange: RedisExchange) -&gt; None:\n    self._uid = uid\n    self._exchange = exchange\n\n    status = self.exchange._client.get(self.exchange._active_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisMailbox.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: RedisExchange\n</code></pre> <p>Exchange client.</p>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisMailbox.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>Mailbox address/identifier.</p>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisMailbox.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this mailbox client.</p> Warning <p>This does not close the mailbox in the exchange. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this mailbox client.\n\n    Warning:\n        This does not close the mailbox in the exchange. I.e., the exchange\n        will still accept new messages to this mailbox, but this client\n        will no longer be listening for them.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisMailbox.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed. Note that this will be cast to an int which is required by the Redis API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed. Note that this will\n            be cast to an int which is required by the Redis API.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    _timeout = int(timeout) if timeout is not None else 1\n    while True:\n        status = self.exchange._client.get(\n            self.exchange._active_key(self.mailbox_id),\n        )\n        if status is None:\n            raise AssertionError(\n                f'Status for mailbox {self.mailbox_id} did not exist in '\n                'Redis server. This means that something incorrectly '\n                'deleted the key.',\n            )\n        elif status == _MailboxState.INACTIVE.value:\n            raise MailboxClosedError(self.mailbox_id)\n\n        raw = self.exchange._client.blpop(\n            [self.exchange._queue_key(self.mailbox_id)],\n            timeout=_timeout,\n        )\n        if raw is None and timeout is not None:\n            raise TimeoutError(\n                f'Timeout waiting for next message for {self.mailbox_id} '\n                f'after {timeout} seconds.',\n            )\n        elif raw is None:  # pragma: no cover\n            continue\n\n        # Only passed one key to blpop to result is [key, item]\n        assert isinstance(raw, (tuple, list))\n        assert len(raw) == 2  # noqa: PLR2004\n        if raw[1] == _CLOSE_SENTINEL:  # pragma: no cover\n            raise MailboxClosedError(self.mailbox_id)\n        message = BaseMessage.model_deserialize(raw[1])\n        assert isinstance(message, get_args(Message))\n        logger.debug(\n            'Received %s to %s',\n            type(message).__name__,\n            self.mailbox_id,\n        )\n        return message\n</code></pre>"},{"location":"api/exchange/thread/","title":"academy.exchange.thread","text":"<code>academy/exchange/thread.py</code>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange","title":"ThreadExchange","text":"<pre><code>ThreadExchange()\n</code></pre> <p>               Bases: <code>ExchangeMixin</code></p> <p>Local process message exchange for threaded agents.</p> <p>This exchange uses <code>Queues</code> as mailboxes for agents running as separate threads within the same process. This exchange is helpful for local testing but not much more.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._queues: dict[EntityId, Queue[Message]] = {}\n    self._behaviors: dict[AgentId[Any], type[Behavior]] = {}\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange.</p> <p>Unlike most exchange clients, this will close all of the mailboxes.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange.\n\n    Unlike most exchange clients, this will close all of the mailboxes.\n    \"\"\"\n    for queue in self._queues.values():\n        queue.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    if aid not in self._queues or self._queues[aid].closed():\n        self._queues[aid] = Queue()\n        self._behaviors[aid] = behavior\n        logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.register_client","title":"register_client","text":"<pre><code>register_client(name: str | None = None) -&gt; ClientId\n</code></pre> <p>Create a new client identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientId</code>           \u2013            <p>Unique identifier for the client's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def register_client(\n    self,\n    name: str | None = None,\n) -&gt; ClientId:\n    \"\"\"Create a new client identifier and associated mailbox.\n\n    Args:\n        name: Optional human-readable name for the client.\n\n    Returns:\n        Unique identifier for the client's mailbox.\n    \"\"\"\n    cid = ClientId.new(name=name)\n    self._queues[cid] = Queue()\n    logger.debug('Registered %s in %s', cid, self)\n    return cid\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exists.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exists.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    queue = self._queues.get(uid, None)\n    if queue is not None and not queue.closed():\n        queue.close()\n        if isinstance(uid, AgentId):\n            self._behaviors.pop(uid, None)\n        logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    for aid, type_ in self._behaviors.items():\n        if behavior is type_ or (\n            allow_subclasses and issubclass(type_, behavior)\n        ):\n            found.append(aid)\n    alive = tuple(aid for aid in found if not self._queues[aid].closed())\n    return alive\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.get_mailbox","title":"get_mailbox","text":"<pre><code>get_mailbox(uid: EntityId) -&gt; ThreadMailbox\n</code></pre> <p>Get a client to a specific mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>EntityId of the mailbox.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ThreadMailbox</code>           \u2013            <p>Mailbox client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def get_mailbox(self, uid: EntityId) -&gt; ThreadMailbox:\n    \"\"\"Get a client to a specific mailbox.\n\n    Args:\n        uid: EntityId of the mailbox.\n\n    Returns:\n        Mailbox client.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n    \"\"\"\n    queue = self._queues.get(uid, None)\n    if queue is None:\n        raise BadEntityIdError(uid)\n    return ThreadMailbox(uid, self, queue)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    queue = self._queues.get(uid, None)\n    if queue is None:\n        raise BadEntityIdError(uid)\n    try:\n        queue.put(message)\n        logger.debug('Sent %s to %s', type(message).__name__, uid)\n    except QueueClosedError as e:\n        raise MailboxClosedError(uid) from e\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchange.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnboundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self: Exchange,\n    aid: AgentId[BehaviorT],\n) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n    return UnboundRemoteHandle(self, aid)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadMailbox","title":"ThreadMailbox","text":"<pre><code>ThreadMailbox(\n    uid: EntityId,\n    exchange: ThreadExchange,\n    queue: Queue[Message],\n)\n</code></pre> <p>Client protocol that listens to incoming messages to a mailbox.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def __init__(\n    self,\n    uid: EntityId,\n    exchange: ThreadExchange,\n    queue: Queue[Message],\n) -&gt; None:\n    self._uid = uid\n    self._exchange = exchange\n    self._queue = queue\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadMailbox.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: ThreadExchange\n</code></pre> <p>Exchange client.</p>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadMailbox.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>Mailbox address/identifier.</p>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadMailbox.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this mailbox client.</p> Warning <p>This does not close the mailbox in the exchange. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this mailbox client.\n\n    Warning:\n        This does not close the mailbox in the exchange. I.e., the exchange\n        will still accept new messages to this mailbox, but this client\n        will no longer be listening for them.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadMailbox.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    try:\n        message = self._queue.get(timeout=timeout)\n        logger.debug(\n            'Received %s to %s',\n            type(message).__name__,\n            self.mailbox_id,\n        )\n        return message\n    except QueueClosedError as e:\n        raise MailboxClosedError(self.mailbox_id) from e\n</code></pre>"},{"location":"api/launcher/","title":"academy.launcher","text":"<code>academy/launcher/__init__.py</code>"},{"location":"api/launcher/#academy.launcher.Launcher","title":"Launcher","text":"<p>               Bases: <code>Protocol</code></p> <p>Agent launcher protocol.</p> <p>A launcher manages the create and execution of agents on remote resources.</p>"},{"location":"api/launcher/#academy.launcher.Launcher.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the launcher and shutdown agents.</p> Source code in <code>academy/launcher/__init__.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the launcher and shutdown agents.\"\"\"\n    ...\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    exchange: Exchange,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; RemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Exchange the agent will use for messaging.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> Source code in <code>academy/launcher/__init__.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    exchange: Exchange,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; RemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        exchange: Exchange the agent will use for messaging.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Handle to the agent.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.running","title":"running","text":"<pre><code>running() -&gt; set[AgentId[Any]]\n</code></pre> <p>Get a set of IDs for all running agents.</p> <p>Returns:</p> <ul> <li> <code>set[AgentId[Any]]</code>           \u2013            <p>Set of agent IDs corresponding to all agents launched by this             launcher that have not completed yet.</p> </li> </ul> Source code in <code>academy/launcher/__init__.py</code> <pre><code>def running(self) -&gt; set[AgentId[Any]]:\n    \"\"\"Get a set of IDs for all running agents.\n\n    Returns:\n        Set of agent IDs corresponding to all agents launched by this \\\n        launcher that have not completed yet.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.wait","title":"wait","text":"<pre><code>wait(\n    agent_id: AgentId[Any], *, timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> </ul> Source code in <code>academy/launcher/__init__.py</code> <pre><code>def wait(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Args:\n        agent_id: ID of launched agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/launcher/executor/","title":"academy.launcher.executor","text":"<code>academy/launcher/executor.py</code>"},{"location":"api/launcher/executor/#academy.launcher.executor.ExecutorLauncher","title":"ExecutorLauncher","text":"<pre><code>ExecutorLauncher(\n    executor: Executor,\n    *,\n    close_exchange: bool = True,\n    max_restarts: int = 0\n)\n</code></pre> <p>Launcher that wraps a <code>concurrent.futures.Executor</code>.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>               (<code>Executor</code>)           \u2013            <p>Executor used for launching agents. Note that this class takes ownership of the <code>executor</code>.</p> </li> <li> <code>close_exchange</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Passed along to the <code>Agent</code> constructor. This should typically be <code>True</code>, the default, when the executor runs agents in separate processes, but should be <code>False</code> for the <code>ThreadPoolExecutor</code> to avoid closing shared exchange objects.</p> </li> <li> <code>max_restarts</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum times to restart an agent if it exits with an error.</p> </li> </ul> Source code in <code>academy/launcher/executor.py</code> <pre><code>def __init__(\n    self,\n    executor: Executor,\n    *,\n    close_exchange: bool = True,\n    max_restarts: int = 0,\n) -&gt; None:\n    self._executor = executor\n    self._close_exchange = close_exchange\n    self._max_restarts = max_restarts\n    self._acbs: dict[AgentId[Any], _ACB[Any]] = {}\n    self._future_to_acb: dict[Future[None], _ACB[Any]] = {}\n</code></pre>"},{"location":"api/launcher/executor/#academy.launcher.executor.ExecutorLauncher.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the launcher and shutdown agents.</p> Source code in <code>academy/launcher/executor.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the launcher and shutdown agents.\"\"\"\n    logger.debug('Waiting for agents to shutdown...')\n    for acb in self._acbs.values():\n        if acb.done.is_set() and acb.future is not None:\n            # Raise possible errors from agents so user is sure\n            # to see them.\n            acb.future.result()\n    self._executor.shutdown(wait=True, cancel_futures=True)\n    logger.debug('Closed launcher (%s)', self)\n</code></pre>"},{"location":"api/launcher/executor/#academy.launcher.executor.ExecutorLauncher.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    exchange: Exchange,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; RemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Exchange the agent will use for messaging.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RemoteHandle[BehaviorT]</code>           \u2013            <p>Handle (unbound) used to interact with the agent.</p> </li> </ul> Source code in <code>academy/launcher/executor.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    exchange: Exchange,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; RemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        exchange: Exchange the agent will use for messaging.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Handle (unbound) used to interact with the agent.\n    \"\"\"\n    agent_id = (\n        exchange.register_agent(type(behavior), name=name)\n        if agent_id is None\n        else agent_id\n    )\n\n    acb = _ACB(agent_id, behavior, exchange, done=threading.Event())\n    self._acbs[agent_id] = acb\n    self._launch(agent_id)\n\n    return exchange.get_handle(agent_id)\n</code></pre>"},{"location":"api/launcher/executor/#academy.launcher.executor.ExecutorLauncher.running","title":"running","text":"<pre><code>running() -&gt; set[AgentId[Any]]\n</code></pre> <p>Get a set of IDs for all running agents.</p> <p>Returns:</p> <ul> <li> <code>set[AgentId[Any]]</code>           \u2013            <p>Set of agent IDs corresponding to all agents launched by this             launcher that have not completed yet.</p> </li> </ul> Source code in <code>academy/launcher/executor.py</code> <pre><code>def running(self) -&gt; set[AgentId[Any]]:\n    \"\"\"Get a set of IDs for all running agents.\n\n    Returns:\n        Set of agent IDs corresponding to all agents launched by this \\\n        launcher that have not completed yet.\n    \"\"\"\n    running: set[AgentId[Any]] = set()\n    for acb in self._acbs.values():\n        if not acb.done.is_set():\n            running.add(acb.agent_id)\n    return running\n</code></pre>"},{"location":"api/launcher/executor/#academy.launcher.executor.ExecutorLauncher.wait","title":"wait","text":"<pre><code>wait(\n    agent_id: AgentId[Any],\n    *,\n    ignore_error: bool = False,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> Note <p>Calling <code>wait()</code> is only valid after <code>launch()</code> has succeeded.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>ignore_error</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ignore any errors raised by the agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by the agent if <code>ignore_error=False</code>.</p> </li> </ul> Source code in <code>academy/launcher/executor.py</code> <pre><code>def wait(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    ignore_error: bool = False,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Note:\n        Calling `wait()` is only valid after `launch()` has succeeded.\n\n    Args:\n        agent_id: ID of launched agent.\n        ignore_error: Ignore any errors raised by the agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n        Exception: Any exception raised by the agent if\n            `ignore_error=False`.\n    \"\"\"\n    try:\n        acb = self._acbs[agent_id]\n    except KeyError:\n        raise BadEntityIdError(agent_id) from None\n\n    if not acb.done.wait(timeout):\n        raise TimeoutError(\n            f'Agent did not complete within {timeout}s timeout '\n            f'({acb.agent_id})',\n        )\n\n    # The only time _ACB.future is None is between constructing the _ACB\n    # in launch() and creating the future in _launch().\n    assert acb.future is not None\n    # _ACB.done event should only be set in callback of future so\n    # the future must be done.\n    assert acb.future.done()\n\n    if not ignore_error:\n        exc = acb.future.exception()\n        if exc is not None:\n            raise exc\n</code></pre>"},{"location":"api/launcher/thread/","title":"academy.launcher.thread","text":"<code>academy/launcher/thread.py</code>"},{"location":"api/launcher/thread/#academy.launcher.thread.ThreadLauncher","title":"ThreadLauncher","text":"<pre><code>ThreadLauncher()\n</code></pre> <p>Local thread launcher.</p> <p>Launch agents in threads within the current process. This launcher is useful for local testing as the GIL will limit the performance and scalability of agents.</p> Source code in <code>academy/launcher/thread.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._agents: dict[AgentId[Any], _RunningAgent[Any]] = {}\n</code></pre>"},{"location":"api/launcher/thread/#academy.launcher.thread.ThreadLauncher.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the launcher and shutdown agents.</p> Source code in <code>academy/launcher/thread.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the launcher and shutdown agents.\"\"\"\n    logger.debug('Waiting for agents to shutdown...')\n    for aid in self._agents:\n        self._agents[aid].agent.shutdown()\n    for aid in self._agents:\n        self._agents[aid].thread.join()\n    logger.debug('Closed launcher (%s)', self)\n</code></pre>"},{"location":"api/launcher/thread/#academy.launcher.thread.ThreadLauncher.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    exchange: Exchange,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; RemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>exchange</code>               (<code>Exchange</code>)           \u2013            <p>Exchange the agent will use for messaging.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RemoteHandle[BehaviorT]</code>           \u2013            <p>Mailbox used to communicate with agent.</p> </li> </ul> Source code in <code>academy/launcher/thread.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    exchange: Exchange,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; RemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        exchange: Exchange the agent will use for messaging.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Mailbox used to communicate with agent.\n    \"\"\"\n    agent_id = (\n        exchange.register_agent(type(behavior), name=name)\n        if agent_id is None\n        else agent_id\n    )\n\n    agent = Agent(\n        behavior,\n        agent_id=agent_id,\n        exchange=exchange,\n        config=AgentRunConfig(close_exchange_on_exit=False),\n    )\n    thread = threading.Thread(target=agent, name=f'{self}-{agent_id}')\n    thread.start()\n    self._agents[agent_id] = _RunningAgent(agent, thread)\n    logger.debug('Launched agent (%s; %s)', agent_id, behavior)\n\n    return exchange.get_handle(agent_id)\n</code></pre>"},{"location":"api/launcher/thread/#academy.launcher.thread.ThreadLauncher.running","title":"running","text":"<pre><code>running() -&gt; set[AgentId[Any]]\n</code></pre> <p>Get a set of IDs for all running agents.</p> <p>Returns:</p> <ul> <li> <code>set[AgentId[Any]]</code>           \u2013            <p>Set of agent IDs corresponding to all agents launched by this             launcher that have not completed yet.</p> </li> </ul> Source code in <code>academy/launcher/thread.py</code> <pre><code>def running(self) -&gt; set[AgentId[Any]]:\n    \"\"\"Get a set of IDs for all running agents.\n\n    Returns:\n        Set of agent IDs corresponding to all agents launched by this \\\n        launcher that have not completed yet.\n    \"\"\"\n    running: set[AgentId[Any]] = set()\n    for agent_id, agent in self._agents.items():\n        if agent.thread.is_alive():\n            running.add(agent_id)\n    return running\n</code></pre>"},{"location":"api/launcher/thread/#academy.launcher.thread.ThreadLauncher.wait","title":"wait","text":"<pre><code>wait(\n    agent_id: AgentId[Any], *, timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> </ul> Source code in <code>academy/launcher/thread.py</code> <pre><code>def wait(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Args:\n        agent_id: ID of launched agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n    \"\"\"\n    try:\n        agent = self._agents[agent_id]\n    except KeyError:\n        raise BadEntityIdError(agent_id) from None\n\n    agent.thread.join(timeout=timeout)\n    if agent.thread.is_alive():\n        raise TimeoutError()\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and TaPS installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/proxystore/academy\n$ cd academy\n$ tox --devenv venv -e py311\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.11, running <code>$ tox -e p310</code> may still use Python 3.11.</p> <p>To install manually: <pre><code>$ git clone https://github.com/proxystore/academy\n$ cd academy\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>Academy uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>academy/</code>. E.g. the tests for <code>academy/x/y.py</code> are located in <code>tests/x/y_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py311\n# Run a specific test\n$ tox -e py311 -- tests/x/y_test.py::test_z\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs] # If you skipped this step earlier\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li> <p>Create local changes.</p> <ul> <li>Changes should conform to the style and testing guidelines, referenced above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.</li> <li>Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li> <p>Push commits to your fork.</p> <ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the PR and included changes.   A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones in the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#versioning","title":"Versioning","text":"<p>Academy uses semver as its versioning system. Rather, changes are only considered breaking if they change the way an application is run. For example, the command from a prior release no longer works in the following release. While Academy is in major version zero (0.y.z), breaking changes will be released in minor version updates.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. Versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"Academy v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>Academy v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>v{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible in one place.   Attributes that are defined later can be set as <code>None</code> as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format (<code>'name: {}'.format(name)</code>).   Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Use lower-case and no punctuation for log messages, but use upper-case and punctuation for exception values.   <pre><code>logger.info(f'new connection opened to {address}')\nraise ValueError('Name must contain alphanumeric characters only.')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Warning</p> <p>Guides are under development!</p> <ul> <li>Example</li> </ul>"},{"location":"guides/example/","title":"Example","text":""},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#citing-academy","title":"Citing Academy","text":"<p>!!!+ info</p> <pre><code>Check back later.\n</code></pre>"},{"location":"publications/#featured-publications","title":"Featured Publications","text":"<p>!!!+ info</p> <pre><code>Check back later.\n</code></pre>"}]}